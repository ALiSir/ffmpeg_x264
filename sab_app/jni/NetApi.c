#include "NetApi.h"#include <stdlib.h>#include "nc/nc.h"#include "nc/qh_ptc.h"#include "playlib.h"#include <pthread.h>#include <stdio.h>#include <sys/types.h>#include <sys/stat.h>#include <unistd.h>#include <fcntl.h>#include <sys/time.h>#include "alog.h"#include "G711.h"#include "adpcm.h"#include "threadx.h"#include "jni.h"#include "aes_decode.h"#include "h264lib.h"#include "string.h"#define TEMP_BUF_LEN_MAIN 1024*1024*4 //视频帧缓冲区大小#define TEMP_BUF_LEN_SUB 1024*1024*1 //视频帧缓冲区大小#define TEMP_BUF_LEN_PB 1024*1024*4 //远程回放回放缓冲#define AUDIO_BUF_LEN 1024*8//音频帧缓冲区大小#define TALK_SEND_BUF_LEN 1024*8#define AVCODE_NUM 40//通道最大数量#define MAX_RECTABLEITEM 600//一个本地录像文件最大帧数#define MAX_INTERVAl 15//录像分文件最大时间间隔//#define AV_SYNC_TIME 300//音视频同步超时单位ms#define AUDIO_IN_SECOND 2*8192+100 //一秒音频数据长度，加100是因为ipc部分极端时会有9帧的现象typedef enum{    VIDEO_TYPE_Main = 0,    VIDEO_TYPE_Sub = 1,}Video_TYPE;static int g_VideoBuf = TEMP_BUF_LEN_MAIN;/** * 录像文件头 */typedef struct RecFileHeader {    int  type;    int  size;    int  version;    char describe[64];}recFileHeader_t;/** * 录像帧信息 */typedef struct structRecTableItem {    unsigned int    no;         // 索引的序号    unsigned int    frame_rate; // 帧率    unsigned int    offset;     // 数据的位置    unsigned int    size;       // 数据的大小    unsigned int    timestamp;  // 时间戳}recTableItem_t;/** *录像索引表 */typedef struct structRecTableInfo {    char devName[64];    char devAddress[64];    int  devPort;    int  devChannelNum;    int  channelNo;    int  begTime;    int  endTime;    int  max;    int  num;    int  ver;    char unuse[128];    recTableItem_t item[MAX_RECTABLEITEM];}recTableInfo_t;//bool s_bEnterCfg = false;static JavaVM* g_jvm = 0;jobject jobj = 0;jmethodID jmid = 0, jmid1 = 0;jclass jcls = 0;static int frame_no = 0;//FILE* f;/** * 实时播放结构 */typedef struct avcodec_jni{    int handle;    int live;//是否解码    int status;//实时状态    long vd_handle;//解码结构体地址    char* tempbuf;//解码后视频帧数据指针    int mInitLen;    int tempbuf_len;//解码后视频帧数据长度    adpcm_state* adstate;//adpcm解码    char* audiobuf;//音频buf    int width;    int height;    int frame_sub_type;//帧 子类型mjpeg 和 h264    int Iframe_flag;//第一个I帧    int raw_len;//码流统计    int frame_num;//帧数统计    int tick;//时间计数    int audio_len;    int audio_tick;//音频时间计数    int sec;    int usec;    pthread_t pid;//视频数据发送线程    int pidflag;//视频数据发送线程 标示    int pbflag;//回调函数标示    pthread_mutex_t v_lock;//解码线程和发送线程线程锁    event_t event;    int flag;//发送线程结束标示    int recflag;//录像标示    FILE* fd;    int first_flag;//录像第一帧标示    int last_time;//前一帧时间    char recname[128];    recTableInfo_t recinfo;}av_t;/** * 对讲结构 */typedef struct talk_jni{    int talkid;    int type;    char* audiobuf;    char* sendbuf;    int flag;    int audio_tick;    int audio_len;    adpcm_state* adstate;    //FILE* fd;//test}talk_t;/** * 回放结构 */typedef struct playback_jni{    int handle;    long vd_handle;    adpcm_state* adstate;    char* tempbuf;    int tempbuf_len;    char* audiobuf;    int audio_tick;    int audio_len;    int raw_len;    int width;    int height;    int status;    int frame_sub_type;    int Iframe_flag;    int sec;    int usec;    int pidflag;    int pbflag;    pthread_t pid;    pthread_mutex_t p_lock;    event_t event;    int tick;    int frame_num;    int flag;    FILE* fd;    int no;//本地回放记录回放的i帧序号    int local_pidflag;    int local_endflag;    pthread_t local_pid;}playback_t;talk_t talk;av_t av[AVCODE_NUM];playback_t playback;static int tick = 0;pthread_t tickpid;int tickflag = 0;//char tempbuf[TEMP_BUF_LEN] = {0};//char* tempbuf = 0;/** * 计时器 */void* TickThread(){    while(tickflag)    {        tick++;        sleep(1);    }    return NULL;}/** * 初始化 */JNIEXPORT jboolean JNICALL Java_com_hdcctv_issmobile_NetApi_Init(JNIEnv *env, jobject obj){    int i = 0;    for(i = 0;i < AVCODE_NUM;i++)    {        av[i].handle = -1;        av[i].live = 0;        av[i].vd_handle = 0;        av[i].tempbuf = NULL;        av[i].audiobuf = NULL;        av[i].adstate = NULL;        av[i].pid = -1;        av[i].pidflag = 0;        av[i].width = 0;        av[i].height = 0;        av[i].frame_sub_type = 0;        av[i].Iframe_flag = 0;        av[i].tempbuf_len = 0;        av[i].raw_len = 0;        av[i].tick = -1;        av[i].frame_num = 0;        av[i].flag = 0;        av[i].fd = NULL;    }    //for(i = 0;i<AVCODE_NUM;i++)    {        talk.talkid = -1;        //talk.type = 0;        talk.audiobuf = NULL;        talk.adstate = NULL;        talk.sendbuf = NULL;        talk.flag = 0;    }    {        playback.handle = -1;        playback.vd_handle = 0;        playback.adstate = NULL;        playback.tempbuf = NULL;        playback.audiobuf = NULL;        playback.pid = -1;        playback.tempbuf_len = 0;        playback.frame_num = 0;        playback.tick = -1;        playback.flag = 0;        playback.width = 0;        playback.height = 0;        playback.frame_sub_type = 0;        playback.Iframe_flag = 0;        playback.sec = 0;        playback.usec = 0;        playback.pid = -1;        playback.pidflag = 0;        playback.fd = NULL;        playback.local_endflag = 1;    }    tickflag = 1;    pthread_create(&tickpid,NULL,(void*)TickThread,NULL);    //tempbuf = (char*)malloc(TEMP_BUF_LEN);    nc_init();    ffmpeg_init();    return JNI_TRUE;}/** * 退出 */JNIEXPORT jboolean JNICALL Java_com_hdcctv_issmobile_NetApi_Done(JNIEnv *env, jobject obj){    LOGI("NET_SDK_Cleanup");    //if(tempbuf != NULL)    //{    //      free(tempbuf);    //}    //(*env)->DeleteLocalRef(env,g_jvm);    g_jvm = 0;    //(*env)->DeleteLocalRef(env,jobj);    jobj = 0;    //jmid = 0, jmid1 = 0;    //jcls = 0;    //releasePlayer();    int i = 0;    for(i = 0;i < AVCODE_NUM;i++)    {        av[i].handle = -1;        //if(av[i].v_lock > 0)        //{        //      av[i].v_lock = -1;        //}        //if(av[i].pid>0)        //{        //      av[i].v_lo;        //}        if(av[i].vd_handle != 0)        {            video_ended(&av[i].vd_handle);        }        if(av[i].tempbuf != NULL)        {            free(av[i].tempbuf);            av[i].tempbuf = NULL;        }        if(av[i].audiobuf != NULL)        {            free(av[i].audiobuf);            av[i].audiobuf = NULL;        }        if(av[i].adstate != NULL)        {            adpcm_end(av[i].adstate);            av[i].adstate = NULL;        }        if(av[i].fd != NULL)        {            fclose(av[i].fd);            av[i].fd = NULL;        }    }    //for(i=0;i<AVCODE_NUM;i++)    //{    talk.talkid = -1;    //talk.type = 0;    if(talk.audiobuf != NULL)    {        free(talk.audiobuf);        talk.audiobuf = NULL;    }    if(talk.adstate != NULL)    {        adpcm_end(talk.adstate);        talk.adstate = NULL;    }    if(talk.sendbuf != NULL)    {        free(talk.sendbuf);        talk.sendbuf = NULL;    }    //}    playback.handle = -1;    if(playback.vd_handle != 0)    {        video_ended(&playback.vd_handle);    }    if(playback.adstate != NULL)    {        free(playback.adstate);        playback.adstate = NULL;    }    if(playback.tempbuf != NULL)    {        free(playback.tempbuf);        playback.tempbuf = NULL;    }    if(playback.audiobuf != NULL)    {        free(playback.audiobuf);        playback.audiobuf = NULL;    }    if(playback.fd != NULL)    {        fclose(playback.fd);        playback.fd = NULL;    }    nc_done();    tickflag = 0;    pthread_join(tickpid,NULL);    return JNI_TRUE;}/** * 设置视频模式 */JNIEXPORT jint JNICALL Java_com_hdcctv_issmobile_NetApi_SetVideoMode(JNIEnv * env, jobject obj,jint videomode){    if(VIDEO_TYPE_Sub == (jint)videomode)    {        g_VideoBuf = TEMP_BUF_LEN_SUB;    }    else if(VIDEO_TYPE_Main == (jint)videomode)    {        g_VideoBuf = TEMP_BUF_LEN_MAIN;    }    else        return -1;    return 0;}/** * 搜索设备 */JNIEXPORT jint JNICALL Java_com_hdcctv_issmobile_NetApi_SearchDevice(JNIEnv * env, jobject obj,jobject deviceinfolist,jobject device){    /*  jclass list_cls = (*env)->FindClass(env,"java/util/ArrayList;");       if(list_cls == NULL)       {         LOGI("findClass error");         return NULL;       }       jmethodID list_costruct = (*env)->GetMethodID(env,list_cls,"init","()V");//获取构造函数       jobject list_obj = (*env)->NewObject(env,list_cls,list_costruct);//构造一个对象       //或得Arraylist类中的 add()方法ID，其方法原型为： boolean add(Object object) ;       jmethodID list_add = (*env)->GetMethodID(env,list_cls,"add","(Ljava/lang/Object;)Z");       jclass info_cls = (*env)->FindClass(env,"Lcom/hdcctv/issmobile/devicemanage/SearchDeviceInfo;");//获取SearchDeviceInfo引用       //获得该类型的构造函数  函数名为 <init> 返回类型必须为 void 即 V       jmethodID info_costruct = (*env)->GetMethodID(env,info_cls,"init","(Ljava/lang/String;II)V");*/    jclass list_cls = (*env)->GetObjectClass(env,deviceinfolist);    if(list_cls == NULL)    {        LOGI("GetObjectClass");        return -99;    }    //jmethodID list_costruct = (*env)->GetMethodID(env,list_cls,"<init>","()V");//获取构造函数    //或得Arraylist类中的 add()方法ID，其方法原型为： boolean add(Object object) ;    jmethodID list_add = (*env)->GetMethodID(env,list_cls,"add","(Ljava/lang/Object;)Z");//Z表示boolean类型    //jclass info_cls = (*env)->FindClass(env,"com/hdcctv/issmobile/devicemanage/SearchDeviceInfo;");//获取SearchDeviceInfo引用    jclass info_cls = (*env)->GetObjectClass(env,device);//FindClass无法找到，原因未知，直接传入类，暂时解决该问题    if(info_cls == NULL)    {        LOGI("GetObjectClasseee");        return -99;    }    //获得该类型的构造函数  函数名为 <init> 返回类型必须为 void 即 V    jmethodID info_costruct = (*env)->GetMethodID(env,info_cls,"<init>","(ILjava/lang/String;III)V");    ptc_mcast_searchs_t searchs;    memset(&searchs,0,sizeof(ptc_mcast_searchs_t));    int ret = nc_searchDev(&searchs);    int i=0;    char str[64];    {        memset(str,0,64);        snprintf(str,64,"%d.%d.%d.%d",searchs.search[i].net.ip1[0],searchs.search[i].net.ip1[1],searchs.search[i].net.ip1[2],searchs.search[i].net.ip1[3]);        //LOGE("%s,%0x %0x %0x %0x",str,searchs.search[i].net.ip1[0],searchs.search[i].net.ip1[1],searchs.search[i].net.ip1[2],searchs.search[i].net.ip1[3]);        jstring addr = (*env)->NewStringUTF(env,str);        int type = 0;        if(NC_PTC_Qihan == searchs.search[i].nc_ptc_type)            type = 0;        else if(NC_PTC_HuaYi == searchs.search[i].nc_ptc_type)            type = 1;        else if(NC_PTC_YuShi == searchs.search[i].nc_ptc_type)            type = 2;        else if(NC_PTC_XiongMai == searchs.search[i].nc_ptc_type)            type = 5;        jobject device_obj = (*env)->NewObject(env,info_cls,info_costruct,(jint)type,addr,(jint)searchs.search[i].net.dev_port,(jint)searchs.search[i].net.stream_port,(jint)searchs.search[i].base.video_input_num);        (*env)->CallBooleanMethod(env,deviceinfolist,list_add,device_obj);        (*env)->DeleteLocalRef (env, addr);    }    return ret;}/** * 设置缓冲区 * @param m_sec:缓冲时间 */JNIEXPORT jint JNICALL Java_com_hdcctv_issmobile_NetApi_SetBuffer(JNIEnv *env, jobject obj,jint m_sec){    return nc_setBuffer(m_sec*1000);}/** * 登陆 * @param ip:地址  port:端口  username:用户名 password：密码 *//*JNIEXPORT jint JNICALL Java_com_hdcctv_issmobile_NetApi_Login(JNIEnv *env, jobject obj,jstring ip, jint port, jstring username, jstring password){        const char* str_ip = (*env)->GetStringUTFChars(env,ip,NULL);        const char* str_user = (*env)->GetStringUTFChars(env,username,NULL);        const char* str_pwd = (*env)->GetStringUTFChars(env,password,NULL);        int userID = nc_login((char*)str_ip, port, (char*)str_user, (char*)str_pwd, (NC_CB)NULL, NULL);        if(userID < 0)                LOGI("login failed!");        (*env)->ReleaseStringUTFChars(env,ip,str_ip);        (*env)->ReleaseStringUTFChars(env,username,str_user);        (*env)->ReleaseStringUTFChars(env,password,str_pwd);        return (jint)userID;}*/void AlarmCallback(int userid, void *data, unsigned int len, void *pUser){    nc_dev* dev = (nc_dev*)pUser;    int type = 1;    ptc_log_t* log = (ptc_log_t*)data;    //LOGE("ip = %d type(%d) sub(%d) channel(%d) ",log->time,log->type,log->sub_type,log->channel);    JNIEnv* env = 0;    (*g_jvm)->AttachCurrentThread(g_jvm,&env,NULL);    static jclass s_jc = 0;    static jmethodID s_jm = 0;    if (env != 0)    {        if(s_jc == 0)        {            s_jc = (*env)->GetObjectClass(env,jobj);        }        if(s_jm == 0)        {            s_jm = (*env)->GetMethodID(env,s_jc, "showAlarm", "(II)V");        }        if(s_jm != 0)        {            (*env)->CallVoidMethod(env,jobj, s_jm, (jint)userid,type);        }    }    (*g_jvm)->DetachCurrentThread(g_jvm);}/** * 开启报警 * @param ip:地址  port:端口  username:用户名 password：密码 */JNIEXPORT jint JNICALL Java_com_hdcctv_issmobile_NetApi_Login2(JNIEnv *env, jobject obj,jint devicetype,jstring id,jstring ip, jint port,jint sport, jstring username, jstring password){    if(g_jvm == 0)    {        (*env)->GetJavaVM(env,&g_jvm);        //env->GetJavaVM(&g_jvm);    }    if(jobj == 0)    {        jobj = (*env)->NewGlobalRef(env,obj);        //jobj = env->NewGlobalRef(obj);    }    const char* str_id = (*env)->GetStringUTFChars(env,id,NULL);    const char* str_ip = (*env)->GetStringUTFChars(env,ip,NULL);    const char* str_user = (*env)->GetStringUTFChars(env,username,NULL);    const char* str_pwd = (*env)->GetStringUTFChars(env,password,NULL);    nc_dev dev;    DeviceInit(&dev,(int)devicetype,str_id,str_ip,(int)port,(int)sport,str_user,str_pwd);    int userID = nc_login_v2(&dev,AlarmCallback,(void*)&dev);    if(userID < 0)        LOGI("login failed!");    (*env)->ReleaseStringUTFChars(env,id,str_id);    (*env)->ReleaseStringUTFChars(env,ip,str_ip);    (*env)->ReleaseStringUTFChars(env,username,str_user);    (*env)->ReleaseStringUTFChars(env,password,str_pwd);    return (jint)userID;}/** * 登出 * @param userid:用户id */JNIEXPORT jboolean JNICALL Java_com_hdcctv_issmobile_NetApi_Logout(JNIEnv *env, jobject obj, jint userid){    return nc_logout((int)userid);}/** * 获取设备在线状态 * @param userid:用户id */JNIEXPORT jint JNICALL Java_com_hdcctv_issmobile_NetApi_GetOnlineStatus(JNIEnv *env, jobject obj, jint userid){    return nc_getOnlineStatus((int)userid);}/** *设置是否解码 flag == 0代表不解码，flag == 1代表解码 */JNIEXPORT jint JNICALL Java_com_hdcctv_issmobile_NetApi_SetLiveFlag(JNIEnv *env, jobject obj, jint handle,jint flag){    int i=0;    for(i=0;i<AVCODE_NUM;i++)    {        if(av[i].handle == (int)handle)        {            av[i].live = flag;        }    }    return 0;}/** * 实时预览显示线程 * @param param：实时播放结构体 */void SendFrame(void* param){    av_t* av_info = (av_t*)param;    JNIEnv* env = 0;    static jclass s_jc = 0;    static jmethodID s_jm = 0;    av_info->flag = 1;    (*g_jvm)->AttachCurrentThread(g_jvm,&env,NULL);    jbyteArray byteArray= (*env)->NewByteArray(env,av_info->mInitLen);    while(av_info->pidflag)    {        if(eventx_wait(&av_info->event,1000) != 0)        {            continue;        }        if(!av_info->pidflag)            break;        pthread_mutex_lock(&av_info->v_lock);        //LOGI("len %d width = %d height = %d",av_info->tempbuf_len,av_info->width,av_info->height);        int status = av_info->status;        int width = av_info->width;        int height = av_info->height;        int handle = av_info->handle;        int len = av_info->tempbuf_len;        int raw_len = 0;        int num = 0;        if(status >=  10)//不会再有        {            av_info->status = 0;        }        else        {            //char* buf = (char*)malloc(len+1);            if(av_info->tempbuf != NULL)                (*env)->SetByteArrayRegion(env,byteArray, 0, len, (jbyte*)av_info->tempbuf);            else            {                pthread_mutex_unlock(&av_info->v_lock);                continue;            }            av_info->tempbuf_len = 0;            av_info->status = 0;            if(av_info->tick == -1)                av_info->tick = tick;            if(tick>av_info->tick)            {                //LOGI("tick %d %d",tick,av_info->tick);                av_info->tick = tick;                raw_len = av_info->raw_len;                av_info->raw_len = 0;                num = av_info->frame_num;                av_info->frame_num = 0;            }            else            {                raw_len = -1;                num = -1;            }        }        pthread_mutex_unlock(&av_info->v_lock);        if(av_info->pidflag == 0)            break;        if (env != 0)        {            if(s_jc == 0)            {                s_jc = (*env)->GetObjectClass(env,jobj);            }            if(s_jm == 0)            {                s_jm = (*env)->GetMethodID(env,s_jc, "showVideo", "(I[BIIIII)V");            }            if(s_jm != 0)            {                (*env)->CallVoidMethod(env,jobj, s_jm, handle, byteArray,width,height,raw_len,num,status);                //av_info->tempbuf_len = 0;            }        }    }    (*env)->DeleteLocalRef(env,byteArray);    (*g_jvm)->DetachCurrentThread(g_jvm);    av_info->flag = 0;}void ShowStatus(int handle,int status,int arg1,int arg2){    JNIEnv* env = 0;    (*g_jvm)->AttachCurrentThread(g_jvm,&env,NULL);    static jclass s_jc = 0;    static jmethodID s_jm = 0;    if (env != 0)    {        if(s_jc == 0)        {            s_jc = (*env)->GetObjectClass(env,jobj);        }        if(s_jm == 0)        {            s_jm = (*env)->GetMethodID(env,s_jc, "showStatus", "(IIII)V");        }        if(s_jm != 0)        {            (*env)->CallVoidMethod(env,jobj, s_jm, (jint)handle, (jint)status,(jint)arg1,(jint)arg2);        }    }    (*g_jvm)->DetachCurrentThread(g_jvm);}/** * 实时预览回调接口 * @param lLiveHandle:实时播放handle data:帧数据 len：帧数据长度  pUser:实时播放结构体 */void LiveDataCallback(int lLiveHandle, void *data, unsigned int len, void *pUser){    ptc_frame_head_t* frameInfo = (ptc_frame_head_t*)data;    int head_len = sizeof(ptc_frame_head_t);    av_t* av_info = (av_t*)pUser;    if(av_info->handle == -1)        return;    else        av_info->pbflag = 1;    //struct timeval startTime;    //struct timeval endTime;    //memset(&startTime,0,sizeof(struct timeval));    //memset(&endTime,0,sizeof(struct timeval));    //gettimeofday(&startTime,NULL);    if(frameInfo->frame_type>PTC_FRAME_INFO)//状态帧    {        /*   pthread_mutex_lock(&av_info->v_lock);           av_info->status = frameInfo->frame_type;           av_info->tempbuf_len = 1;//SetByteArrayRegion 如果等于0会不会you           eventx_post(&av_info->event);           pthread_mutex_unlock(&av_info->v_lock);*/        av_info->pbflag = 0;        ShowStatus(lLiveHandle,frameInfo->frame_type,0,0);        return;    }    if(frameInfo->frame_type == PTC_FRAME_INFO)    {        /*  pthread_mutex_lock(&av_info->v_lock);          av_info->status = frameInfo->frame_type;          av_info->tempbuf_len = 1;          ptc_cfg_info_t* info = (ptc_cfg_info_t*)(data+head_len);          //LOGE("power = %d  wifisg = %d",info->power,info->wifisg);          av_info->width = info->power;//宽用做电量高作为wifi信号          av_info->height = info->wifisg;          eventx_post(&av_info->event);          pthread_mutex_unlock(&av_info->v_lock);*/        av_info->pbflag = 0;        ptc_cfg_info_t* info = (ptc_cfg_info_t*)(data+head_len);        ShowStatus(lLiveHandle,frameInfo->frame_type,info->power,info->wifisg);        return;    }    if(frameInfo->frame_type == PTC_FRAME_NONE || frameInfo->frame_sub_type == PTC_FRAME_NONE)//容错    {        av_info->pbflag = 0;        return;    }    if(av_info->Iframe_flag == 0)    {        if(frameInfo->frame_type != 1)        {            av_info->pbflag = 0;            return;        }        else            av_info->Iframe_flag = 1;    }    if(frameInfo->security == 1)    {        if(Aes_Decode((char*)frameInfo+head_len,&frameInfo->len,frameInfo->padding_bytes)<0)        {            LOGE("aes failed");            av_info->pbflag = 0;            return;        }    }    if(frameInfo->frame_type != 3)    {        if(frameInfo->frame_type == 1 && frameInfo->frame_sub_type == PTC_VIDEO_ENCODE_H264)        {            int width=0,height=0;            int ret = getWidthAndHeight((unsigned char*)data+head_len,len - head_len,&width,&height);            if(ret == 0)            {                if(abs(frameInfo->width - width)<10 && abs(frameInfo->height - height)<10)                {                }                else                {                    frameInfo->width = width;                    frameInfo->height = height;                }            }        }        if(frameInfo->width*frameInfo->height*2 > av_info->mInitLen ||frameInfo->width<176 || frameInfo->height<144)// frameInfo->width*frameInfo->height < 100*100)        {            /* pthread_mutex_lock(&av_info->v_lock);             av_info->status = 10;             av_info->width = frameInfo->width;             av_info->height = frameInfo->height;             av_info->tempbuf_len = 1;//SetByteArrayRegion 如果等于0会不会you             av_info->Iframe_flag = 0;                     av_info->pbflag = 0;             pthread_mutex_unlock(&av_info->v_lock);*/            av_info->pbflag = 0;            ShowStatus(lLiveHandle,10,frameInfo->width,frameInfo->height);            return;        }    }    if(av_info->recflag)    {        localRecord(av_info,data);    }    if(av_info->live == 0)//不解码    {        av_info->pbflag = 0;        return;    }    if(frameInfo->frame_type != 3)    {        int Outsize = 0;        int beganFlag = 0;        pthread_mutex_lock(&av_info->v_lock);        av_info->status = frameInfo->frame_type;        av_info->frame_num++;        if(av_info->tempbuf!=NULL)        {            if((av_info->vd_handle == 0) || (av_info->frame_sub_type!=frameInfo->frame_sub_type) || (av_info->width!=frameInfo->width) || (av_info->height!=frameInfo->height))            {                if(av_info->vd_handle != 0)                    video_ended(&av_info->vd_handle);                beganFlag = 1;            }            if(beganFlag==1 && video_began(frameInfo->frame_sub_type, frameInfo->width, frameInfo->height, &av_info->vd_handle)<0)            {                LOGD("video_began");                av_info->Iframe_flag = 0;                video_ended(&av_info->vd_handle);                av_info->pbflag = 0;                pthread_mutex_unlock(&av_info->v_lock);                return;            }            av_info->frame_sub_type = frameInfo->frame_sub_type;            av_info->width = frameInfo->width;            av_info->height = frameInfo->height;            memset(av_info->tempbuf, 0, av_info->mInitLen);            if(video_decode(av_info->vd_handle, (char*)data+head_len, frameInfo->len, av_info->tempbuf, &av_info->width, &av_info->height,&Outsize)<0)            {                LOGE("video_decode");                //LOGE("rate(%d) type(%d) subtype(%d) height(%d) width(%d)",frameInfo->frame_rate,frameInfo->frame_type,frameInfo->frame_sub_type,frameInfo->height,                //      frameInfo->width);                //av_info->Iframe_flag = 0;                //video_ended(&av_info->vd_handle);//返回错误时不要结束，否则永远都报错，（帧数据异常？）                //usleep(10*1000);                av_info->pbflag = 0;                pthread_mutex_unlock(&av_info->v_lock);                return;            }            av_info->raw_len += frameInfo->len;            av_info->tempbuf_len = Outsize;            av_info->sec = frameInfo->sec;            av_info->usec = frameInfo->usec;        }        eventx_post(&av_info->event);        pthread_mutex_unlock(&av_info->v_lock);    }    else if(frameInfo->frame_type == 3)    {        //int start = av_info->sec*1000+av_info->usec/1000;        //int current = frameInfo->sec*1000+frameInfo->usec/1000;        //if(abs(current-start) > 2*1000/av_info->frameNo)        //   return;        if(frameInfo->len > 2048)            return;        if(tick>av_info->audio_tick)        {            av_info->audio_tick = tick;            av_info->audio_len = 0;        }        if(av_info->audio_len> AUDIO_IN_SECOND)        {            av_info->pbflag = 0;            return;        }        memset(av_info->audiobuf,0,AUDIO_BUF_LEN);        unsigned int outsize;        //LOGE("subtype %d %d",frameInfo->frame_sub_type,frameInfo->len);        if(frameInfo->frame_sub_type == 1)            outsize = ALawDecode_len((short *)av_info->audiobuf,(const uint8_t *)data+head_len,(size_t)len - head_len);        else if(frameInfo->frame_sub_type == 3)            outsize = ULawDecode_len((short *)av_info->audiobuf,(const uint8_t *)data+head_len,(size_t)len - head_len);        else if(frameInfo->frame_sub_type == 2)        {            //outsize = 2*adpcm_decoder((unsigned char *)data+head_len, (short *)av_info->audiobuf, len - head_len, av_info->adstate);            adpcm_state* adstate = data+head_len+4;            outsize = 2*adpcm_decoder((unsigned char *)data+head_len+8, (short *)av_info->audiobuf, len - head_len - 8, adstate);        }        else if(frameInfo->frame_sub_type == 4)        {            memcpy(av_info->audiobuf,data+head_len,len - head_len);            outsize = len - head_len;        }        else        {            av_info->pbflag = 0;            return;        }        av_info->audio_len += outsize;        // unsigned int outsize = 2048;        //if(av_info->recflag)        //  {        //fwrite((char*)frameInfo,1,head_len,av_info->fd);        //fwrite((char*)av_info->audiobuf,1,outsize,av_info->fd);        //   fread(frameInfo,1,head_len,av_info->fd);        //    fread(av_info->audiobuf,1,2048,av_info->fd);        // }        ///LOGI("frameInfo.length: %d %d %d",len - head_len,frameInfo->len,outsize);        //LOGI("time: %d %d ",frameInfo->sec,frameInfo->usec);        JNIEnv* env = 0;        (*g_jvm)->AttachCurrentThread(g_jvm,&env,NULL);        static jclass s_jc = 0;        static jmethodID s_jm = 0;        if (env != 0)        {            if(s_jc == 0)            {                s_jc = (*env)->GetObjectClass(env,jobj);            }            if(s_jm == 0)            {                s_jm = (*env)->GetMethodID(env,s_jc, "showAudio", "(I[BII)V");            }            if(s_jm != 0)            {                jbyteArray byteArray= (*env)->NewByteArray(env,outsize);                (*env)->SetByteArrayRegion(env,byteArray, 0, outsize, (jbyte*)av_info->audiobuf);                (*env)->CallVoidMethod(env,jobj, s_jm, (jint)lLiveHandle, byteArray,outsize,frameInfo->frame_sub_type);                (*env)->DeleteLocalRef(env,byteArray);            }        }        (*g_jvm)->DetachCurrentThread(g_jvm);    }    av_info->pbflag = 0;    //gettimeofday(&endTime,NULL);    //if(frameInfo->frame_type!=3)    // {    //    if(frameInfo->frame_type == 1)    //     LOGI("iiiiiiii");    //LOGI("frame %d %d %d %d",frameInfo->frame_type,frameInfo->sec,frameInfo->usec,frameInfo->len);    //LOGI("start sec(%d) usc(%d)",startTime.tv_sec,startTime.tv_usec);    //LOGI("end sec(%d) usc(%d)",endTime.tv_sec,endTime.tv_usec);    //  }    //LOGI("*****");}/** * @param userid:登陆的用户id channel:通道号  streamtype：流类型 *//*JNIEXPORT jint JNICALL Java_com_hdcctv_issmobile_NetApi_LivePlay(JNIEnv *env, jobject obj, jint userid, jint channel, jint streamtype){        if(g_jvm == 0)        {                (*env)->GetJavaVM(env,&g_jvm);                //env->GetJavaVM(&g_jvm);        }        if(jobj == 0)        {                jobj = (*env)->NewGlobalRef(env,obj);                //jobj = env->NewGlobalRef(obj);        }        int i = 0;        for(i = 0;i < AVCODE_NUM;i++)        {                if(av[i].handle < 0)                        break;        }        if(i==AVCODE_NUM)          return -1;        //av[i].vd = (videodecode_t*)malloc(sizeof(videodecode_t));        //memset(av[i].vd,0,sizeof(videodecode_t));        av[i].vd_handle = 0;        av[i].live = 1;        av[i].status = 0;        av[i].tempbuf = (char*)malloc(TEMP_BUF_LEN);        av[i].audiobuf = (char*)malloc(AUDIO_BUF_LEN);        av[i].adstate = adpcm_begin();        av[i].width = 0;        av[i].height = 0;        av[i].frame_sub_type = 0;        av[i].Iframe_flag = 0;        av[i].tempbuf_len = 0;        av[i].raw_len = 0;        av[i].tick = -1;        av[i].frame_num = 0;        av[i].flag = 1;        //av[i].audio_tick = 0;        int lHandle = nc_startRts((int)userid, (int)channel, (int)streamtype, LiveDataCallback, &av[i]);        av[i].pidflag = 1;        av[i].handle = lHandle;        av[i].recflag = 0;        eventx_init(&av[i].event);        if(pthread_mutex_init(&av[i].v_lock,NULL)!=0)        {                LOGI("mutex init");                return (jint)-1;        }        if(pthread_create(&av[i].pid,NULL,SendFrame,(void*)&av[i])!=0)        {                LOGI("pthread_create");                return(jint)-1;        }        //add_play_info(channel, lHandle, pavcodec);        return lHandle;}*/JNIEXPORT jint JNICALL Java_com_hdcctv_issmobile_NetApi_LivePlay2(JNIEnv *env, jobject obj,jint devicetype,jstring id, jstring ip, jint port,jint sport, jstring username, jstring password, jint channel, jint streamtype){    if(g_jvm == 0)    {        (*env)->GetJavaVM(env,&g_jvm);        //env->GetJavaVM(&g_jvm);    }    if(jobj == 0)    {        jobj = (*env)->NewGlobalRef(env,obj);        //jobj = env->NewGlobalRef(obj);    }    jboolean iscopy;    const char* str_id = (*env)->GetStringUTFChars(env,id,NULL);    const char* str_ip = (*env)->GetStringUTFChars(env,ip,NULL);    const char* str_user = (*env)->GetStringUTFChars(env,username,NULL);    const char* str_pwd = (*env)->GetStringUTFChars(env,password,NULL);    if((str_ip == NULL) || (str_user == NULL) || (str_pwd == NULL))    {        (*env)->ReleaseStringUTFChars(env,id,str_id);        (*env)->ReleaseStringUTFChars(env,ip,str_ip);        (*env)->ReleaseStringUTFChars(env,username,str_user);        (*env)->ReleaseStringUTFChars(env,password,str_pwd);        return (jint)-1;    }    nc_dev dev;    DeviceInit(&dev,(int)devicetype,str_id,str_ip,(int)port,(int)sport,str_user,str_pwd);    (*env)->ReleaseStringUTFChars(env,id,str_id);    (*env)->ReleaseStringUTFChars(env,ip,str_ip);    (*env)->ReleaseStringUTFChars(env,username,str_user);    (*env)->ReleaseStringUTFChars(env,password,str_pwd);    int i = 0;    for(i = 0;i < AVCODE_NUM;i++)    {        if(av[i].handle < 0)            break;    }    if(i==AVCODE_NUM)    {        return -1;    }    AvInit(&av[i],(int)streamtype);    int lHandle = nc_startRts_v2(&dev, (int)channel, (int)streamtype, LiveDataCallback, &av[i]);    av[i].handle = lHandle;    if(pthread_mutex_init(&av[i].v_lock,NULL)!=0)    {        AvDone(&av[i]);        return (jint)-1;    }    if(pthread_create(&av[i].pid,NULL,SendFrame,(void*)&av[i])!=0)    {        LOGI("pthread_create");        AvDone(&av[i]);        return(jint)-1;    }    // char filename[128];    // av[i].fd = NULL;    //sprintf(filename,"/mnt/sdcard/tempdata/record/audioTest.rec");    // av[i].fd = fopen(filename,"rb");    //av[i].recflag = 1;    //add_play_info(channel, lHandle, pavcodec);    return lHandle;}/** * 打开实时视频 * @param handle：用户handle */JNIEXPORT jboolean JNICALL Java_com_hdcctv_issmobile_NetApi_StopLivePlay(JNIEnv *env, jobject obj, jint handle){    int i=0;    for(i=0;i<AVCODE_NUM;i++)    {        if(av[i].handle == (int)handle)        {            //fclose(av[i].fd);            //av[i].fd = NULL;            AvDone(&av[i]);            break;        }    }    return JNI_TRUE;}/** * 获取通道数量 * @param userid：用户id *//*JNIEXPORT jint JNICALL Java_com_hdcctv_issmobile_NetApi_GetChannelNum(JNIEnv *env, jobject obj, jint userid){        return (jint)nc_getChannelNum((int)userid);}*//** * 获取通道数量2 * @param ip：地址 port：端口 username:用户名  password：密码 *//*JNIEXPORT jint JNICALL Java_com_hdcctv_issmobile_NetApi_GetChannelNumE(JNIEnv *env, jobject obj,jint devicetype, jstring ip, jint port, jstring username, jstring password){    jboolean iscopy;    const char* str_ip = (*env)->GetStringUTFChars(env,ip,NULL);    const char* str_user = (*env)->GetStringUTFChars(env,username,NULL);    const char* str_pwd = (*env)->GetStringUTFChars(env,password,NULL);    if((str_ip == NULL) || (str_user == NULL) || (str_pwd == NULL))     {        (*env)->ReleaseStringUTFChars(env,ip,str_ip);        (*env)->ReleaseStringUTFChars(env,username,str_user);        (*env)->ReleaseStringUTFChars(env,password,str_pwd);        return (jint)-1;     }    nc_dev dev;     DeviceInit(&dev,(int)devicetype,str_ip,(int)port,str_user,str_pwd);    ptc_cfg_ability_t ability;    memset(&ability,0,sizeof(ptc_cfg_ability_t));    int ret = nc_getAbility_v2(&dev,&ability);    if(ret < 0 )    {            (*env)->ReleaseStringUTFChars(env,ip,str_ip);            (*env)->ReleaseStringUTFChars(env,username,str_user);            (*env)->ReleaseStringUTFChars(env,password,str_pwd);            return ret;    }    (*env)->ReleaseStringUTFChars(env,ip,str_ip);    (*env)->ReleaseStringUTFChars(env,username,str_user);    (*env)->ReleaseStringUTFChars(env,password,str_pwd);    return  (jint)ability.video_input_num;}*/JNIEXPORT jint JNICALL Java_com_hdcctv_issmobile_NetApi_GetChannelNum2(JNIEnv *env, jobject obj,jint devicetype,jstring id, jstring ip, jint port,jint sport, jstring username, jstring password){    jboolean iscopy;    const char* str_id = (*env)->GetStringUTFChars(env,id,NULL);    const char* str_ip = (*env)->GetStringUTFChars(env,ip,NULL);    const char* str_user = (*env)->GetStringUTFChars(env,username,NULL);    const char* str_pwd = (*env)->GetStringUTFChars(env,password,NULL);    if((str_ip == NULL) || (str_user == NULL) || (str_pwd == NULL))    {        (*env)->ReleaseStringUTFChars(env,id,str_id);        (*env)->ReleaseStringUTFChars(env,ip,str_ip);        (*env)->ReleaseStringUTFChars(env,username,str_user);        (*env)->ReleaseStringUTFChars(env,password,str_pwd);        return (jint)-1;    }    nc_dev dev;    DeviceInit(&dev,(int)devicetype,str_id,str_ip,(int)port,(int)sport,str_user,str_pwd);    (*env)->ReleaseStringUTFChars(env,id,str_id);    (*env)->ReleaseStringUTFChars(env,ip,str_ip);    (*env)->ReleaseStringUTFChars(env,username,str_user);    (*env)->ReleaseStringUTFChars(env,password,str_pwd);    return nc_getChannelNum_v2(&dev);}/** * 获取设备id号； *///JNIEXPORT jstring JNICALL Java_com_hdcctv_issmobile_NetApi_GetDeviceId(JNIEnv *env, jobject obj, jint devicetype,jstring id,jstring ip, jint port,jint sport, jstring username, jstring password)JNIEXPORT jint JNICALL Java_com_hdcctv_issmobile_NetApi_GetAbility(JNIEnv *env, jobject obj, jint devicetype,                                                                   jstring id,jstring ip, jint port,jint sport, jstring username, jstring password,jobject device){    jboolean iscopy;    const char* str_id = (*env)->GetStringUTFChars(env,id,NULL);    const char* str_ip = (*env)->GetStringUTFChars(env,ip,NULL);    const char* str_user = (*env)->GetStringUTFChars(env,username,NULL);    const char* str_pwd = (*env)->GetStringUTFChars(env,password,NULL);    if((str_ip == NULL) || (str_user == NULL) || (str_pwd == NULL) || (str_id == NULL))    {        (*env)->ReleaseStringUTFChars(env,id,str_id);        (*env)->ReleaseStringUTFChars(env,ip,str_ip);        (*env)->ReleaseStringUTFChars(env,username,str_user);        (*env)->ReleaseStringUTFChars(env,password,str_pwd);        return NULL;    }    jclass string_cls = (*env)->GetObjectClass(env,device);//FindClass无法找到，原因未知，直接传入类，暂时解决该问题    if(string_cls == NULL)    {        LOGI("GetObjectClasseee");        return -99;    }    jfieldID alarm_id = (*env)->GetFieldID(env, string_cls, "alarm_id", "Ljava/lang/String;");    jfieldID channel = (*env)->GetFieldID(env,string_cls,"channelnum","I");    if(alarm_id == NULL || channel == NULL)    {        LOGI("GetObjectClasseee");        return -99;    }    nc_dev dev;    DeviceInit(&dev,(int)devicetype,str_id,str_ip,(int)port,sport,str_user,str_pwd);    ptc_cfg_ability_t ability;    memset(&ability,0,sizeof(ptc_cfg_ability_t));    int ret = nc_getAbility_v2(&dev, &ability);    (*env)->ReleaseStringUTFChars(env,id,str_id);    (*env)->ReleaseStringUTFChars(env,ip,str_ip);    (*env)->ReleaseStringUTFChars(env,username,str_user);    (*env)->ReleaseStringUTFChars(env,password,str_pwd);    if(ret>=0)    {        jstring str_alarmid = (*env)->NewStringUTF(env, ability.base.dev_id);        (*env)->SetObjectField(env, device, alarm_id, str_alarmid);        (*env)->SetIntField(env,device,channel,ability.video_input_num);        (*env)->DeleteLocalRef (env, str_alarmid);    }    return ret;}/** * 获取流状态 * @param handle：用户句柄 */JNIEXPORT jint JNICALL Java_com_hdcctv_issmobile_NetApi_GetStreamStatus(JNIEnv *env, jobject obj, jint handle){    return (jint)nc_getRtsStatus((int)handle);}/** * 设置流类型 * @param handle：用户句柄 level：流类型 */JNIEXPORT jint JNICALL Java_com_hdcctv_issmobile_NetApi_SetStreamLevel(JNIEnv *env, jobject obj, jint handle, jint level){    int i=0;    for(i=0;i<AVCODE_NUM;i++)    {        if(av[i].handle == (int)handle)        {            pthread_mutex_lock(&av[i].v_lock);            av[i].Iframe_flag = 0;            pthread_mutex_unlock(&av[i].v_lock);            break;        }    }    return (jint)nc_setRtsLevel((int)handle, (int)level);}/** * 发送ptz命令 * @param handle：用户句柄 cmd：命令 param：参数 *//*JNIEXPORT jint JNICALL Java_com_hdcctv_issmobile_NetApi_ControlPTZByHandle(JNIEnv *env, jobject obj, jint handle, jint cmd, jint param){        return nc_controlPTZ_byRts((int)handle, (int)cmd, (int)param);}*//** * 根据通道发送ptz命令 * @param userid：用户id channel：通道号  cmd：命令 param：参数 *//*JNIEXPORT jint JNICALL Java_com_hdcctv_issmobile_NetApi_ControlPTZByChannel(JNIEnv *env, jobject obj, jint userid, jint channel, jint cmd, jint param){        return (jint)0;        }*/JNIEXPORT jint JNICALL Java_com_hdcctv_issmobile_NetApi_ControlPTZ2(JNIEnv *env, jobject obj,jint devicetype,jstring id,jstring ip, jint port,jint sport, jstring username, jstring password, jint channel, jint cmd, jint param){    jboolean iscopy;    const char* str_id = (*env)->GetStringUTFChars(env,id,NULL);    const char* str_ip = (*env)->GetStringUTFChars(env,ip,NULL);    const char* str_user = (*env)->GetStringUTFChars(env,username,NULL);    const char* str_pwd = (*env)->GetStringUTFChars(env,password,NULL);    if((str_ip == NULL) || (str_user == NULL) || (str_pwd == NULL))    {        (*env)->ReleaseStringUTFChars(env,id,str_id);        (*env)->ReleaseStringUTFChars(env,ip,str_ip);        (*env)->ReleaseStringUTFChars(env,username,str_user);        (*env)->ReleaseStringUTFChars(env,password,str_pwd);        return (jint)-1;    }    nc_dev dev;    DeviceInit(&dev,(int)devicetype,str_id,str_ip,(int)port,(int)sport,str_user,str_pwd);    int ret = nc_controlPTZ_v2(&dev, (int)channel, cmd,param);    (*env)->ReleaseStringUTFChars(env,id,str_id);    (*env)->ReleaseStringUTFChars(env,ip,str_ip);    (*env)->ReleaseStringUTFChars(env,username,str_user);    (*env)->ReleaseStringUTFChars(env,password,str_pwd);    return ret;/** * 获取报警输出端口数量 * @param userid：用户id *//*JNIEXPORT jint JNICALL Java_com_hdcctv_issmobile_NetApi_GetAlarmOutNum(JNIEnv *env, jobject obj, jint userid){        ptc_cfg_ability_t ability;        int ret = nc_getAbility((int)userid,&ability);        if(ret<0)        {                return (jint)ret;        }        return (jint)ability.alarm_output_num;}*/    JNIEXPORT jint JNICALL Java_com_hdcctv_issmobile_NetApi_GetAlarmOutNum2(JNIEnv *env, jobject obj, jint devicetype,jstring id,jstring ip, jint port,jint sport, jstring username, jstring password)    {        jboolean iscopy;        const char* str_id = (*env)->GetStringUTFChars(env,id,NULL);        const char* str_ip = (*env)->GetStringUTFChars(env,ip,NULL);        const char* str_user = (*env)->GetStringUTFChars(env,username,NULL);        const char* str_pwd = (*env)->GetStringUTFChars(env,password,NULL);        if((str_ip == NULL) || (str_user == NULL) || (str_pwd == NULL) || (str_id == NULL))        {            (*env)->ReleaseStringUTFChars(env,id,str_id);            (*env)->ReleaseStringUTFChars(env,ip,str_ip);            (*env)->ReleaseStringUTFChars(env,username,str_user);            (*env)->ReleaseStringUTFChars(env,password,str_pwd);            return (jint)-1;        }        nc_dev dev;        DeviceInit(&dev,(int)devicetype,str_id,str_ip,(int)port,sport,str_user,str_pwd);        ptc_cfg_ability_t ability;        int ret = nc_getAbility_v2(&dev, &ability);        (*env)->ReleaseStringUTFChars(env,id,str_id);        (*env)->ReleaseStringUTFChars(env,ip,str_ip);        (*env)->ReleaseStringUTFChars(env,username,str_user);        (*env)->ReleaseStringUTFChars(env,password,str_pwd);        if(ret<0)            return ret;        return (jint)ability.alarm_output_num;    }/** * 获取报警输出端口状态 * @param userid：用户id config：输出的配置信息 *//*JNIEXPORT jint JNICALL Java_com_hdcctv_issmobile_NetApi_GetAlarmOut(JNIEnv *env, jobject obj, jint userid,jcharArray config){        ptc_cfg_status_t status;        int ret = nc_getDeviceStatus((int)userid,&status);        (*env)->SetCharArrayRegion(env,config,0,sizeof(status.io_out),(jchar*)&status.io_out);        return (jcharArray)ret;}*/    JNIEXPORT jint JNICALL Java_com_hdcctv_issmobile_NetApi_GetAlarmOut2(JNIEnv *env, jobject obj,jint devicetype,jstring id, jstring ip, jint port,jint sport, jstring username, jstring password,jcharArray config)    {        jboolean iscopy;        const char* str_id = (*env)->GetStringUTFChars(env,id,NULL);        const char* str_ip = (*env)->GetStringUTFChars(env,ip,NULL);        const char* str_user = (*env)->GetStringUTFChars(env,username,NULL);        const char* str_pwd = (*env)->GetStringUTFChars(env,password,NULL);        if((str_ip == NULL) || (str_user == NULL) || (str_pwd == NULL))        {            (*env)->ReleaseStringUTFChars(env,id,str_id);            (*env)->ReleaseStringUTFChars(env,ip,str_ip);            (*env)->ReleaseStringUTFChars(env,username,str_user);            (*env)->ReleaseStringUTFChars(env,password,str_pwd);            return (jint)-1;        }        nc_dev dev;        DeviceInit(&dev,(int)devicetype,str_id,str_ip,(int)port,(int)sport,str_user,str_pwd);        ptc_cfg_status_t status;        int ret = nc_getDeviceStatus_v2(&dev,&status);        (*env)->SetCharArrayRegion(env,config,0,sizeof(status.io_out),(jchar*)&status.io_out);        (*env)->ReleaseStringUTFChars(env,id,str_id);        (*env)->ReleaseStringUTFChars(env,ip,str_ip);        (*env)->ReleaseStringUTFChars(env,username,str_user);        (*env)->ReleaseStringUTFChars(env,password,str_pwd);        return (jcharArray)ret;    }/** * 设置报警输出 * @param userid：用户id config：输入的配置信息 *//*JNIEXPORT jint JNICALL Java_com_hdcctv_issmobile_NetApi_SetAlarmOut(JNIEnv *env, jobject obj, jint userid,jcharArray config){        ptc_cfg_status_t status;        jboolean iscopy;        jchar* buf = (*env)->GetCharArrayElements(env,config,&iscopy);        if(nc_getDeviceStatus((int)userid,&status) < 0)        {                return (jint)-1;        }        memcpy(&status.io_out,buf,sizeof(long long));        int ret = nc_setDeviceStatus((int)userid,&status);        (*env)->ReleaseCharArrayElements(env,config,buf,0);        return (jint)ret;}*/    JNIEXPORT jint JNICALL Java_com_hdcctv_issmobile_NetApi_SetAlarmOut2(JNIEnv *env, jobject obj,jint devicetype,jstring id, jstring ip, jint port,jint sport, jstring username, jstring password,jcharArray config)    {        jboolean iscopy;        const char* str_id = (*env)->GetStringUTFChars(env,id,NULL);        const char* str_ip = (*env)->GetStringUTFChars(env,ip,NULL);        const char* str_user = (*env)->GetStringUTFChars(env,username,NULL);        const char* str_pwd = (*env)->GetStringUTFChars(env,password,NULL);        if((str_ip == NULL) || (str_user == NULL) || (str_pwd == NULL))        {            (*env)->ReleaseStringUTFChars(env,id,str_id);            (*env)->ReleaseStringUTFChars(env,ip,str_ip);            (*env)->ReleaseStringUTFChars(env,username,str_user);            (*env)->ReleaseStringUTFChars(env,password,str_pwd);            return (jint)-1;        }        nc_dev dev;        DeviceInit(&dev,(int)devicetype,str_id,str_ip,(int)port,(int)sport,str_user,str_pwd);        (*env)->ReleaseStringUTFChars(env,id,str_id);        (*env)->ReleaseStringUTFChars(env,ip,str_ip);        (*env)->ReleaseStringUTFChars(env,username,str_user);        (*env)->ReleaseStringUTFChars(env,password,str_pwd);        ptc_cfg_status_t status;        jchar* buf = (*env)->GetCharArrayElements(env,config,&iscopy);        int ret = -1;        ret = nc_getDeviceStatus_v2(&dev,&status);        if(ret < 0)        {            (*env)->ReleaseCharArrayElements(env,config,buf,0);            return (jint)ret;        }        memcpy(&status.io_out,buf,sizeof(long long));        ret = nc_setDeviceStatus_v2(&dev,&status);        if(ret < 0)        {            (*env)->ReleaseCharArrayElements(env,config,buf,0);            return (jint)ret;        }        (*env)->ReleaseCharArrayElements(env,config,buf,0);        return (jcharArray)0;    }/** * 对讲回调 * @param lTalkId：id data：音频数据 len：数据长度  pUser：对讲结构 */    void TalkCallback(int lTalkId, void *data, unsigned int len, void *pUser)    {        ptc_frame_head_t* frameInfo = (ptc_frame_head_t*)data;        int head_len = sizeof(ptc_frame_head_t);        talk_t* talk = (talk_t*)pUser;        if(frameInfo->frame_type == PTC_FRAME_NONE || frameInfo->frame_sub_type == PTC_FRAME_NONE)//容错            return;        if(frameInfo->frame_type == 3)        {//audio format            if(tick > talk->audio_tick)            {                talk->audio_len = 0;                talk->audio_tick = tick;            }            if(talk->audio_len > AUDIO_IN_SECOND)                return;            memset(talk->audiobuf,0,AUDIO_BUF_LEN);            unsigned int outsize;            if(frameInfo->frame_sub_type == 1)                outsize = ALawDecode_len((short *)talk->audiobuf,(const uint8_t *)data+head_len,(size_t)len - head_len);            else if(frameInfo->frame_sub_type == 3)                outsize = ULawDecode_len((short *)talk->audiobuf,(const uint8_t *)data+head_len,(size_t)len - head_len);            else if(frameInfo->frame_sub_type == 2)            {                adpcm_state* adstate = data+head_len+4;                //outsize = 2*adpcm_decoder((unsigned char *)data+head_len+8, (short *)talk->audiobuf, len - head_len, talk->adstate);                outsize = 2*adpcm_decoder((unsigned char *)data+head_len+8, (short *)talk->audiobuf, len - head_len-8, adstate);            }            else if(frameInfo->frame_sub_type == 4)            {                memcpy(talk->audiobuf,data+head_len,len - head_len);                outsize = len - head_len;            }            else                return;            talk->audio_len += outsize;            JNIEnv* env = 0;            (*g_jvm)->AttachCurrentThread(g_jvm,&env,NULL);            static jclass s_jc = 0;            static jmethodID s_jm = 0;            if (env != 0)            {                if(s_jc == 0)                {                    s_jc = (*env)->GetObjectClass(env,jobj);                }                if(s_jm == 0)                {                    s_jm = (*env)->GetMethodID(env,s_jc, "showTalk", "(I[BII)V");                }                if(s_jm != 0)                {                    jbyteArray byteArray= (*env)->NewByteArray(env,outsize);                    (*env)->SetByteArrayRegion(env,byteArray, 0, outsize, (jbyte*)talk->audiobuf);                    (*env)->CallVoidMethod(env,jobj, s_jm, (int)lTalkId, byteArray,outsize,frameInfo->frame_sub_type);                    (*env)->DeleteLocalRef(env,byteArray);                }            }            (*g_jvm)->DetachCurrentThread(g_jvm);        }    }/** * 获取音频编码类型 * @param userid：用户id *//*JNIEXPORT jint JNICALL Java_com_hdcctv_issmobile_NetApi_GetTalkType(JNIEnv *env, jobject obj, jint userid){        ptc_cfg_audio_ability_t ability;        int ret = nc_getAudioAbility(userid, &ability);        if(ret<0)                return (jint)ret;        talk.type = ability.encode_type;        return (jint)ability.encode_type;}*/    JNIEXPORT jint JNICALL Java_com_hdcctv_issmobile_NetApi_GetTalkType2(JNIEnv *env, jobject obj,jint devicetype,jstring id, jstring ip, jint port,jint sport, jstring username, jstring password,jobject info)    {        jboolean iscopy;        const char* str_id = (*env)->GetStringUTFChars(env,id,NULL);        const char* str_ip = (*env)->GetStringUTFChars(env,ip,NULL);        const char* str_user = (*env)->GetStringUTFChars(env,username,NULL);        const char* str_pwd = (*env)->GetStringUTFChars(env,password,NULL);        if((str_ip == NULL) || (str_user == NULL) || (str_pwd == NULL))        {            (*env)->ReleaseStringUTFChars(env,id,str_id);            (*env)->ReleaseStringUTFChars(env,ip,str_ip);            (*env)->ReleaseStringUTFChars(env,username,str_user);            (*env)->ReleaseStringUTFChars(env,password,str_pwd);            return (jint)-1;        }        jclass info_cls = (*env)->GetObjectClass(env,info);//FindClass无法找到，原因未知，直接传入类，暂时解决该问题        if(info_cls == NULL)        {            LOGI("GetObjectClasseee");            return -99;        }        //获得该类型的构造函数   返回类型必须为 void 即 V 如果有混淆代码需要保持该名称不改变        jmethodID info_set = (*env)->GetMethodID(env,info_cls,"setVoiceInfo","(IIII)V");        nc_dev dev;        DeviceInit(&dev,(int)devicetype,str_id,str_ip,(int)port,(int)sport,str_user,str_pwd);        ptc_cfg_ability_t ability;        memset(&ability,0,sizeof(ptc_cfg_ability_t));        int ret = nc_getAbility_v2(&dev, &ability);        (*env)->ReleaseStringUTFChars(env,id,str_id);        (*env)->ReleaseStringUTFChars(env,ip,str_ip);        (*env)->ReleaseStringUTFChars(env,username,str_user);        (*env)->ReleaseStringUTFChars(env,password,str_pwd);        if(ret<0)            return (jint)ret;        //talk.type = ability.audio_ability.encode_type;        //ability.audio_ability.frame_size;        //LOGE("sample_rate(%d) bit_width(%d) encode_type(%d) frame_size(%d)",ability.audio_ability.sample_rate,ability.audio_ability.bit_width,ability.audio_ability.encode_type,ability.audio_ability.frame_size);        (*env)->CallVoidMethod(env,info,info_set,(jint)ability.audio_ability.sample_rate,(jint)ability.audio_ability.bit_width,(jint)ability.audio_ability.encode_type,(jint)ability.audio_ability.frame_size);        return (jint)ability.audio_ability.encode_type;    }/** * 开始对讲 * @param userid：用户id *//*JNIEXPORT jint JNICALL Java_com_hdcctv_issmobile_NetApi_StartTalk(JNIEnv *env, jobject obj, jint userid){        int talkid = -1;        //int i=0;        //for(i=0;i<AVCODE_NUM;i++)        //{        //      if(talk[i].userid < 0)        //              break;        //}        talk.flag = 1;        talk.audiobuf = (char*)malloc(AUDIO_BUF_LEN);        talk.sendbuf = (char*)malloc(sizeof(ptc_frame_head_t)+2048);        talk.adstate = adpcm_begin();        //talk.audio_tick = 0;        frame_no = 0;        talkid = nc_startTalk((int)userid, TalkCallback, &talk);        talk.talkid = talkid;        //if((f = fopen("/storage/emulated/0/issmobile_data/bb","wb+"))==NULL)        //{        //      LOGI("open+++++++");        //}        return (jint)talkid;}*/    JNIEXPORT jint JNICALL Java_com_hdcctv_issmobile_NetApi_StartTalk2(JNIEnv *env, jobject obj,jint devicetype, jstring id,jstring ip, jint port, jint sport,jstring username, jstring password)    {        int talkid = -1;        jboolean iscopy;        const char* str_id = (*env)->GetStringUTFChars(env,id,NULL);        const char* str_ip = (*env)->GetStringUTFChars(env,ip,NULL);        const char* str_user = (*env)->GetStringUTFChars(env,username,NULL);        const char* str_pwd = (*env)->GetStringUTFChars(env,password,NULL);        if((str_ip == NULL) || (str_user == NULL) || (str_pwd == NULL))        {            (*env)->ReleaseStringUTFChars(env,id,str_id);            (*env)->ReleaseStringUTFChars(env,ip,str_ip);            (*env)->ReleaseStringUTFChars(env,username,str_user);            (*env)->ReleaseStringUTFChars(env,password,str_pwd);            return (jint)-1;        }        nc_dev dev;        DeviceInit(&dev,(int)devicetype,str_id,str_ip,(int)port,(int)sport,str_user,str_pwd);        talk.flag = 1;        talk.audiobuf = (char*)malloc(AUDIO_BUF_LEN);        talk.sendbuf = (char*)malloc(sizeof(ptc_frame_head_t)+TALK_SEND_BUF_LEN);        talk.adstate = adpcm_begin();        talk.audio_tick = tick;        talk.audio_len = 0;        //talk.audio_tick = 0;        frame_no = 0;        talkid = nc_startTalk_v2(&dev, TalkCallback, &talk);        talk.talkid = talkid;        (*env)->ReleaseStringUTFChars(env,id,str_id);        (*env)->ReleaseStringUTFChars(env,ip,str_ip);        (*env)->ReleaseStringUTFChars(env,username,str_user);        (*env)->ReleaseStringUTFChars(env,password,str_pwd);        return (jint)talkid;    }/** * 停止对讲 * @param talkid：对讲id */    JNIEXPORT jint JNICALL Java_com_hdcctv_issmobile_NetApi_StopTalk(JNIEnv *env, jobject obj, jint talkid)    {        talk.flag = 0;        int ret = nc_stopTalk((int)talkid);        if(talk.audiobuf != NULL)        {            free(talk.audiobuf);            talk.audiobuf = NULL;        }        if(talk.adstate != NULL)        {            adpcm_end(talk.adstate);            talk.adstate = NULL;        }        if(talk.sendbuf != NULL)        {            free(talk.sendbuf);            talk.sendbuf = NULL;        }        talk.talkid = -1;        frame_no = 0;        //fclose(f);        return (jint)ret;    }/** * 发送对讲数据线程 * @param talkid：对讲id buf：音频数据 size：数据长度 */    JNIEXPORT jint JNICALL Java_com_hdcctv_issmobile_NetApi_SendTalk(JNIEnv *env, jobject obj, jint talkid, jshortArray buf, jint size,jint frame_rate,jint type)    {        if(talk.flag == 0)            return (jint)0;        int framhead_len = sizeof(ptc_frame_head_t);        jboolean iscopy;        int outsize = 0;        //char sendbuf = (char*)malloc(1024);        if(talk.sendbuf)            memset(talk.sendbuf,0,framhead_len+TALK_SEND_BUF_LEN);        else            return (jint)-1;        struct timeval tv;        gettimeofday(&tv,NULL);        ptc_frame_head_t* head = talk.sendbuf;        head->no = frame_no++;        head->sec = tv.tv_sec;        head->usec = tv.tv_usec;        head->frame_type = 3;        head->frame_sub_type = type;        head->frame_rate = frame_rate;//???        jshort* rawbuf = (*env)->GetShortArrayElements(env,buf,&iscopy);        //outsize = adpcm_coder(rawbuf,talk.sendbuf+framhead_len, 2*size, talk.adstate);        if(type == 1)            outsize = ALawEncode_len(talk.sendbuf+framhead_len,(short*)rawbuf,2*size);        else if(type == 3)            outsize = ULawEncode_len(talk.sendbuf+framhead_len,(short*)rawbuf,2*size);        else if(type == 2)        {            int no = 0;            outsize = 0;            int count = size/320;            //count = 5;            for(no =0;no<count;no++)            {                *(talk.sendbuf+framhead_len+outsize)=0x00;                *(talk.sendbuf+framhead_len+1+outsize)=0x01;                *(talk.sendbuf+framhead_len+2+outsize)=0x52;                *(talk.sendbuf+framhead_len+3+outsize)=0x00;                memcpy(talk.sendbuf+framhead_len+4+outsize,talk.adstate,sizeof(adpcm_state));                outsize += adpcm_coder(rawbuf+no*320,talk.sendbuf+framhead_len+8+outsize, 320, talk.adstate);                outsize +=8;            }            outsize = count*168;        }        else if(type == 4)        {            outsize = 2*size;            memcpy(talk.sendbuf+framhead_len,(char*)rawbuf,2*size);        }        head->len = outsize;        //if(f)        //{        //      LOGI("open+++++++");        //      fwrite(talk.sendbuf+framhead_len,outsize,1,f);        //}        nc_sendTalk(talkid, talk.sendbuf, outsize+framhead_len);        (*env)->ReleaseShortArrayElements(env,buf,rawbuf,0);        return (jint)0;    }/** * 发送回放数据线程 * @param param：回放结构 */    void SendPlayBackVideo(void* param)    {        playback_t* playback_info = (playback_t*)param;        JNIEnv* env = 0;        static jclass s_jc = 0;        static jmethodID s_jm = 0;        playback_info->flag = 1;        (*g_jvm)->AttachCurrentThread(g_jvm,&env,NULL);        jbyteArray byteArray= (*env)->NewByteArray(env,TEMP_BUF_LEN_PB);        // char* buf = (char*)malloc(TEMP_BUF_LEN);        while(playback_info->pidflag)        {            if(eventx_wait(&playback_info->event,1000) != 0)            {                LOGE("eventx_wait");                continue;            }            if(!playback_info->pidflag)                break;            pthread_mutex_lock(&playback_info->p_lock);            int status = playback_info->status;            int width = playback_info->width;            int height = playback_info->height;            int handle = playback_info->handle;            int len = playback_info->tempbuf_len;            int raw_len = 0;            int num = 0;            int sec = playback_info->sec;            int usec = playback_info->usec;            //LOGE("len = %d",len);            if(playback_info->tempbuf != NULL)            {                (*env)->SetByteArrayRegion(env,byteArray, 0, len, (jbyte*)playback_info->tempbuf);            }            else            {                pthread_mutex_unlock(&playback_info->p_lock);                continue;            }            playback_info->tempbuf_len = 0;            playback_info->status = 0;            //playback_info->frame_num++;            if(playback_info->tick == -1)                playback_info->tick = tick;            if(tick>playback_info->tick)            {                //LOGI("tick %d %d",tick,av_info->tick);                playback_info->tick = tick;                raw_len = playback_info->raw_len;                playback_info->raw_len = 0;                num = playback_info->frame_num;                playback_info->frame_num = 0;            }            else            {                raw_len = -1;                num = -1;            }            pthread_mutex_unlock(&playback_info->p_lock);            if(playback_info->pidflag == 0)            {                break;            }            if (env != 0)            {                if(s_jc == 0)                {                    s_jc = (*env)->GetObjectClass(env,jobj);                }                if(s_jm == 0)                {                    s_jm = (*env)->GetMethodID(env,s_jc, "showPlayBack", "(I[BIIIIIII)V");                }                if(s_jm != 0)                {                    (*env)->CallVoidMethod(env,jobj, s_jm, handle, byteArray,width,height,raw_len,num,sec,usec,status);                }            }        }        (*env)->DeleteLocalRef(env,byteArray);        (*g_jvm)->DetachCurrentThread(g_jvm);        //free(buf);        //buf = NULL;        playback_info->flag = 0;    }/** * 远程回放回调 * @param handle：handle data:回放数据 len：数据长度 pUser：回放结构 */    void PlayBackCallback(int handle,void *data, unsigned int len, void *pUser)    {        ptc_frame_head_t* frameInfo = (ptc_frame_head_t*)data;        int head_len = sizeof(ptc_frame_head_t);        playback_t* playback_info = (playback_t*)pUser;        //LOGI("frameInfo->frame_type(%d) sec(%d) usec(%d)",frameInfo->frame_type,frameInfo->sec,frameInfo->usec);        LOGW("frame_type %d pid %d handle%d",frameInfo->frame_type,playback_info->local_pidflag,playback_info->handle);        if(playback_info->local_pidflag == 0 && playback_info->handle == -1)            return;        else            playback_info->pbflag = 1;        if(frameInfo->frame_type == PTC_FRAME_PBS_END)        {            LOGE("PTC_FRAME_PBS_END+++++");            playback_info->pbflag = 0;            ShowStatus(handle,frameInfo->frame_type,0,0);            return;        }        if(frameInfo->frame_type == PTC_FRAME_NONE || frameInfo->frame_sub_type == PTC_FRAME_NONE)//容错        {            playback_info->pbflag = 0;            ShowStatus(handle,frameInfo->frame_type,0,0);            return;        }        if(frameInfo->frame_type >= PTC_FRAME_STREAM_WAIT)//暂时不用        {            playback_info->pbflag = 0;            return;        }        if(playback_info->Iframe_flag == 0)        {            if(frameInfo->frame_type != 1)            {                playback_info->pbflag = 0;                return;            }            else                playback_info->Iframe_flag = 1;        }        if(frameInfo->security == 1)        {            if(Aes_Decode((char*)frameInfo+head_len,&frameInfo->len,frameInfo->padding_bytes)<0)            {                LOGE("aes failed");                playback_info->pbflag = 0;                return;            }        }        //LOGE("type %d rate = %d  sec %d usec %d",frameInfo->frame_type,frameInfo->frame_rate,frameInfo->sec,frameInfo->usec);        if(frameInfo->frame_type == 1 && frameInfo->frame_sub_type == PTC_VIDEO_ENCODE_H264)        {            int width=0,height=0;            int ret = getWidthAndHeight((unsigned char*)data+head_len,len - head_len,&width,&height);            if(ret == 0)            {                if(abs(frameInfo->width - width)<10 && abs(frameInfo->height - height)<10)                {                }                else                {                    frameInfo->width = width;                    frameInfo->height = height;                }            }        }        if(frameInfo->frame_type != 3)        {            int Outsize = 0;            int beganFlag = 0;            if(frameInfo->width*frameInfo->height*2 > TEMP_BUF_LEN_PB || frameInfo->width*frameInfo->height == 0)            {                pthread_mutex_lock(&playback_info->p_lock);                playback_info->status = 10;                playback_info->height = frameInfo->height;                playback_info->width = frameInfo->width;                playback_info->tempbuf_len = 1;                playback_info->Iframe_flag = 0;                memset(playback_info->tempbuf, 0, TEMP_BUF_LEN_PB);                eventx_post(&playback_info->event);                playback_info->pbflag = 0;                pthread_mutex_unlock(&playback_info->p_lock);                return;            }            pthread_mutex_lock(&playback_info->p_lock);            //  if(playback_info->status >= PTC_FRAME_STREAM_WAIT)            //  {            //     eventx_post(&playback_info->event);            //     pthread_mutex_unlock(&playback_info->p_lock);            //      return;            // }            playback_info->status = 0;            playback_info->frame_num++;            if(playback_info->tempbuf!=NULL )            {                if((playback_info->vd_handle == 0) || (playback_info->frame_sub_type!=frameInfo->frame_sub_type) || (playback_info->width!=frameInfo->width) || (playback_info->height!=frameInfo->height))                {                    if(playback_info->vd_handle != 0)                        video_ended(&playback_info->vd_handle);                    beganFlag = 1;                }                if(beganFlag==1 && video_began(frameInfo->frame_sub_type, frameInfo->width, frameInfo->height, &playback_info->vd_handle)<0)                {                    LOGI("video_began");                    video_ended(&playback_info->vd_handle);                    playback_info->Iframe_flag = 0;                    playback_info->pbflag = 0;                    pthread_mutex_unlock(&playback_info->p_lock);                    return;                }                playback_info->frame_sub_type = frameInfo->frame_sub_type;                playback_info->height = frameInfo->height;                playback_info->width = frameInfo->width;                memset(playback_info->tempbuf, 0, TEMP_BUF_LEN_PB);                if(video_decode(playback_info->vd_handle, (char*)data+head_len, frameInfo->len, playback_info->tempbuf, &playback_info->width, &playback_info->height,&Outsize)<0)                {                    LOGI("video_decode");                    //video_ended(&playback_info->vd_handle);                    playback_info->pbflag = 0;                    pthread_mutex_unlock(&playback_info->p_lock);                    return;                }                playback_info->status = frameInfo->frame_type;                playback_info->tempbuf_len = Outsize;                playback_info->raw_len += frameInfo->len;                playback_info->sec = frameInfo->sec;                playback_info->usec = frameInfo->usec;                eventx_post(&playback_info->event);                pthread_mutex_unlock(&playback_info->p_lock);            }        }        else if(frameInfo->frame_type == 3)        {//audio format            /*      if(frameInfo->frame_sub_type != 2)                  {                      playback_info->audio_tick++;                      if(playback_info->audio_tick%40==0)                        {                          playback_info->audio_tick = 0;                          return;                        }                  }*/            if(frameInfo->len>2048)                return;            if(tick > playback_info->audio_tick)            {                playback_info->audio_tick = tick;                playback_info->audio_len = 0;            }            if(playback_info->audio_len > AUDIO_IN_SECOND)            {                playback_info->pbflag = 0;                return;            }            memset(playback_info->audiobuf,0,AUDIO_BUF_LEN);            unsigned int outsize;            if(frameInfo->frame_sub_type == 1)                outsize = ALawDecode_len((short *)playback_info->audiobuf,(const uint8_t *)data+head_len,(size_t)len - head_len);            else if(frameInfo->frame_sub_type == 3)                outsize = ULawDecode_len((short *)playback_info->audiobuf,(const uint8_t *)data+head_len,(size_t)len - head_len);            else if(frameInfo->frame_sub_type == 2)            {                //outsize = 2*adpcm_decoder((unsigned char *)data+head_len, (short *)av_info->audiobuf, len - head_len, av_info->adstate);                adpcm_state* adstate = data+head_len+4;                outsize = 2*adpcm_decoder((unsigned char *)data+head_len+8, (short *)playback_info->audiobuf, len - head_len - 8, adstate);            }            else if(frameInfo->frame_sub_type == 4)            {                memcpy(playback_info->audiobuf,data+head_len,len - head_len);                outsize = len - head_len;            }            else            {                playback_info->pbflag = 0;                return;            }            playback_info->audio_len += outsize;            JNIEnv* env = 0;            (*g_jvm)->AttachCurrentThread(g_jvm,&env,NULL);            static jclass s_jc = 0;            static jmethodID s_jm = 0;            if (env != 0)            {                if(s_jc == 0)                {                    s_jc = (*env)->GetObjectClass(env,jobj);                }                if(s_jm == 0)                {                    s_jm = (*env)->GetMethodID(env,s_jc, "showPlayBackAudio", "(I[BII)V");                }                if(s_jm != 0)                {                    jbyteArray byteArray= (*env)->NewByteArray(env,outsize);                    (*env)->SetByteArrayRegion(env,byteArray, 0, outsize, (jbyte*)playback_info->audiobuf);                    (*env)->CallVoidMethod(env,jobj, s_jm, (int)handle, byteArray,outsize,frameInfo->frame_sub_type);                    (*env)->DeleteLocalRef(env,byteArray);                }            }            (*g_jvm)->DetachCurrentThread(g_jvm);        }        playback_info->pbflag = 0;        //if(frameInfo->frame_type == 3)        //   LOGI("frameInfo->frame_type(%d)   no(%d) sec(%d) usec(%d) len(%d)",frameInfo->frame_type,frameInfo->no,frameInfo->sec,frameInfo->usec,frameInfo->len);    }/** * 停止远程回放 * */    JNIEXPORT jint JNICALL Java_com_hdcctv_issmobile_NetApi_StartPbs(JNIEnv *env, jobject obj,jint devicetype,                                                                     jstring id,jstring ip, jint port, jint sport,jstring username, jstring password,jint start,jint end,jint size,jint channel,jint type,jint subtype,jintArray fileinfo)    {        if(g_jvm == 0)        {            (*env)->GetJavaVM(env,&g_jvm);            //env->GetJavaVM(&g_jvm);        }        if(jobj == 0)        {            jobj = (*env)->NewGlobalRef(env,obj);            //jobj = env->NewGlobalRef(obj);        }        const char* str_id = (*env)->GetStringUTFChars(env,id,NULL);        const char* str_ip = (*env)->GetStringUTFChars(env,ip,NULL);        const char* str_user = (*env)->GetStringUTFChars(env,username,NULL);        const char* str_pwd = (*env)->GetStringUTFChars(env,password,NULL);        jint* info = (*env)->GetIntArrayElements(env,fileinfo,NULL);        nc_dev dev;        DeviceInit(&dev,(int)devicetype,str_id,str_ip,(int)port,(int)sport,str_user,str_pwd);        ptc_cfg_record_t record;        record.start_time = (int)start;        record.end_time = (int)end;        record.size = (int)size;        record.type = (unsigned char)type;        record.sub_type = (unsigned char)subtype;        record.channel = (unsigned char)channel;        memcpy(record.file_info,(char*)info,sizeof(record.file_info));        (*env)->ReleaseIntArrayElements(env,fileinfo,info,0);        (*env)->ReleaseStringUTFChars(env,id,str_id);        (*env)->ReleaseStringUTFChars(env,ip,str_ip);        (*env)->ReleaseStringUTFChars(env,username,str_user);        (*env)->ReleaseStringUTFChars(env,password,str_pwd);        PlaybackInit();        int handle = nc_startPbs(&dev, &record, PlayBackCallback, (void*)&playback);        playback.handle = handle;        if(pthread_mutex_init(&playback.p_lock,NULL)!=0)        {            LOGI("pthread_mutex_init");            endPlayback();            return(jint)-1;        }        playback.pidflag = 1;        if(pthread_create(&playback.pid,NULL,SendPlayBackVideo,(void*)&playback)!=0)        {            LOGI("pthread_create");            endPlayback();            return(jint)-1;        }        return (jint)handle;    }/** * 停止回放 */    void endPlayback()    {        //if(playback.handle>=0)        {            if(playback.handle>=0)                nc_stopPbs(playback.handle);            playback.handle = -1;            playback.local_pidflag = 0;            if(playback.fd != NULL)            {                fclose(playback.fd);                playback.fd = NULL;            }            while(playback.local_endflag != 1)            {                usleep(10*1000);            }            playback.local_endflag = 1;            playback.pidflag = 0;            eventx_post(&playback.event);            //            while(playback.flag != 0 || playback.pbflag != 0)            {                usleep(10*1000);            }            eventx_unit(&playback.event);            pthread_join(playback.pid,NULL);            if(playback.vd_handle != 0)            {                video_ended(&playback.vd_handle);            }            if(playback.tempbuf != NULL)            {                free(playback.tempbuf);                playback.tempbuf = NULL;            }            if(playback.audiobuf != NULL)            {                free(playback.audiobuf);                playback.audiobuf = NULL;            }            if(playback.adstate != NULL)            {                adpcm_end(playback.adstate);                playback.adstate = NULL;            }            playback.handle = -1;            playback.width = 0;            playback.height = 0;            playback.tempbuf_len = 0;            playback.raw_len = 0;            playback.tick = -1;            playback.frame_num = 0;        }    }/** * 停止远程回放回调 */    JNIEXPORT jint JNICALL Java_com_hdcctv_issmobile_NetApi_StopPbs(JNIEnv *env, jobject obj,jint handle)    {        if(playback.handle == (int)handle)        {            endPlayback();        }        return JNI_TRUE;    }/** * 搜索远程录像 */    JNIEXPORT jint JNICALL Java_com_hdcctv_issmobile_NetApi_SearchRecords(JNIEnv *env, jobject obj,jint devicetype,                                                                          jstring id,jstring ip, jint port,jint sport, jstring username, jstring password,jint type,jint subtype,jint start,jint end,jint channel,jintArray infoarray)    {        jboolean iscopy;        const char* str_id = (*env)->GetStringUTFChars(env,id,NULL);        const char* str_ip = (*env)->GetStringUTFChars(env,ip,NULL);        const char* str_user = (*env)->GetStringUTFChars(env,username,NULL);        const char* str_pwd = (*env)->GetStringUTFChars(env,password,NULL);        jint* info = (*env)->GetIntArrayElements(env,infoarray,NULL);        if((str_ip == NULL) || (str_user == NULL) || (str_pwd == NULL) || (info == NULL))        {            (*env)->ReleaseIntArrayElements(env,infoarray,info,0);            // (*env)->ReleaseCharArrayElements(env,channel,buf,0);            (*env)->ReleaseStringUTFChars(env,id,str_id);            (*env)->ReleaseStringUTFChars(env,ip,str_ip);            (*env)->ReleaseStringUTFChars(env,username,str_user);            (*env)->ReleaseStringUTFChars(env,password,str_pwd);            return (jint)-1;        }        nc_dev dev;        DeviceInit(&dev,(int)devicetype,str_id,str_ip,(int)port,(int)sport,str_user,str_pwd);        ptc_cfg_records_t records;        records.type = (unsigned char)type;        records.sub_type  = (unsigned char)subtype;        records.start_time = (int)start;        records.end_time = (int)end;        records.channel = 1<<channel;        //memcpy(&records.channel,(char*)&channel,sizeof(records.channel));        (*env)->ReleaseStringUTFChars(env,id,str_id);        (*env)->ReleaseStringUTFChars(env,ip,str_ip);        (*env)->ReleaseStringUTFChars(env,username,str_user);        (*env)->ReleaseStringUTFChars(env,password,str_pwd);        int ret = nc_searchRecords(&dev, &records);        if(ret < 0)        {            (*env)->ReleaseIntArrayElements(env,infoarray,info,0);            // (*env)->ReleaseCharArrayElements(env,channel,buf,0);            return ret;        }        int i = 0;        int j = 0;        for(i=0;i<records.num;i++)        {            info[i+j] = records.record[i].start_time;            info[i+j+1] = records.record[i].end_time;            info[i+j+2] = records.record[i].size;            info[i+j+3] = records.record[i].channel;            info[i+j+4] = records.record[i].type;            info[i+j+5] = records.record[i].sub_type;            memcpy(&info[i+j+6],records.record[i].file_info,sizeof(records.record[i].file_info));            j+=(5+32);        }        //(*env)->SetIntRegion        //(*env)->SetIntArrayRegion(env,infoarray,0,sizeof(1024*6),info);        (*env)->ReleaseIntArrayElements(env,infoarray,info,0);        return (jint)records.num;    }/** * 搜索远程日志 */    JNIEXPORT jint JNICALL Java_com_hdcctv_issmobile_NetApi_SearchLogs(JNIEnv *env, jobject obj,jint devicetype,                                                                       jstring id,jstring ip, jint port,jint sport, jstring username, jstring password,jint start,jint end,jintArray infoarray)    {        jboolean iscopy;        const char* str_id = (*env)->GetStringUTFChars(env,id,NULL);        const char* str_ip = (*env)->GetStringUTFChars(env,ip,NULL);        const char* str_user = (*env)->GetStringUTFChars(env,username,NULL);        const char* str_pwd = (*env)->GetStringUTFChars(env,password,NULL);        jint* info = (*env)->GetIntArrayElements(env,infoarray,NULL);        if((str_ip == NULL) || (str_user == NULL) || (str_pwd == NULL) || (info == NULL) || (str_id == NULL))        {            (*env)->ReleaseIntArrayElements(env,infoarray,info,0);            // (*env)->ReleaseCharArrayElements(env,channel,buf,0);            (*env)->ReleaseStringUTFChars(env,id,str_id);            (*env)->ReleaseStringUTFChars(env,ip,str_ip);            (*env)->ReleaseStringUTFChars(env,username,str_user);            (*env)->ReleaseStringUTFChars(env,password,str_pwd);            return (jint)-1;        }        nc_dev dev;        DeviceInit(&dev,(int)devicetype,str_id,str_ip,(int)port,(int)sport,str_user,str_pwd);        ptc_logs_t logs;        logs.start_time = (int)start;        logs.end_time = (int)end;        logs.num = 0;        (*env)->ReleaseStringUTFChars(env,id,str_id);        (*env)->ReleaseStringUTFChars(env,ip,str_ip);        (*env)->ReleaseStringUTFChars(env,username,str_user);        (*env)->ReleaseStringUTFChars(env,password,str_pwd);        int ret = nc_searchLogs(&dev, &logs);        if(ret < 0)        {            (*env)->ReleaseIntArrayElements(env,infoarray,info,0);            // (*env)->ReleaseCharArrayElements(env,channel,buf,0);            return ret;        }        int i = 0;        int j = 0;        for(i=0;i<logs.num;i++)        {            info[i+j] = logs.log[i].time;            info[i+j+1] = logs.log[i].type;            info[i+j+2] = logs.log[i].sub_type;            info[i+j+3] = logs.log[i].channel;            info[i+j+4] = logs.log[i].ch_type;            info[i+j+5] = logs.log[i].sub_type2;            memcpy(&info[i+j+6],logs.log[i].ip,sizeof(logs.log[i].ip));            j+=6;        }        (*env)->ReleaseIntArrayElements(env,infoarray,info,0);        return (jint)logs.num;    }/* * 搜索远程日志2 */    JNIEXPORT jint JNICALL Java_com_hdcctv_issmobile_NetApi_SearchLogs2(JNIEnv *env, jobject obj,jint devicetype,                                                                        jstring id,jstring ip, jint port,jint sport, jstring username, jstring password,jint start,jint end,jintArray infoarray)    {        jboolean iscopy;        const char* str_id = (*env)->GetStringUTFChars(env,id,NULL);        const char* str_ip = (*env)->GetStringUTFChars(env,ip,NULL);        const char* str_user = (*env)->GetStringUTFChars(env,username,NULL);        const char* str_pwd = (*env)->GetStringUTFChars(env,password,NULL);        jint* info = (*env)->GetIntArrayElements(env,infoarray,NULL);        if((str_ip == NULL) || (str_user == NULL) || (str_pwd == NULL) || (info == NULL) || (str_id == NULL))        {            (*env)->ReleaseIntArrayElements(env,infoarray,info,0);            // (*env)->ReleaseCharArrayElements(env,channel,buf,0);            (*env)->ReleaseStringUTFChars(env,id,str_id);            (*env)->ReleaseStringUTFChars(env,ip,str_ip);            (*env)->ReleaseStringUTFChars(env,username,str_user);            (*env)->ReleaseStringUTFChars(env,password,str_pwd);            return (jint)-1;        }        nc_dev dev;        DeviceInit(&dev,(int)devicetype,str_id,str_ip,(int)port,(int)sport,str_user,str_pwd);        ptc_logs_v2_t logs;        logs.start_time = (int)start;        logs.end_time = (int)end;        logs.num = 0;        (*env)->ReleaseStringUTFChars(env,id,str_id);        (*env)->ReleaseStringUTFChars(env,ip,str_ip);        (*env)->ReleaseStringUTFChars(env,username,str_user);        (*env)->ReleaseStringUTFChars(env,password,str_pwd);        int ret = nc_searchLogs_v2(&dev, &logs);        if(ret < 0)        {            (*env)->ReleaseIntArrayElements(env,infoarray,info,0);            // (*env)->ReleaseCharArrayElements(env,channel,buf,0);            return ret;        }        int i = 0;        int j = 0;        for(i=0;i<logs.num;i++)        {            info[i+j] = logs.log_v2[i].time;            info[i+j+1] = logs.log_v2[i].type;            info[i+j+2] = logs.log_v2[i].sub_type;            info[i+j+3] = logs.log_v2[i].channel;            info[i+j+4] = logs.log_v2[i].ch_type;            info[i+j+5] = logs.log_v2[i].sub_type2;            //LOGE("type == %d %d %d %d",logs.log_v2[i].type,logs.log_v2[i].sub_type,logs.log_v2[i].ch_type,logs.log_v2[i].sub_type2);            memcpy(&info[i+j+6],logs.log_v2[i].ip,sizeof(logs.log_v2[i].ip));            memcpy(&info[i+j+7],logs.log_v2[i].data,sizeof(logs.log_v2[i].data));            //LOGE("ddd %d.%d.%d.%d",logs.log_v2[i].ip[0],logs.log_v2[i].ip[1],logs.log_v2[i].ip[2],logs.log_v2[i].ip[3]);            //LOGE("ddd %s",logs.log_v2[i].data);            j+=22;        }        (*env)->ReleaseIntArrayElements(env,infoarray,info,0);        return (jint)logs.num;    }/*JNIEXPORT jint JNICALL Java_com_hdcctv_issmobile_NetApi_SearchLogs2(JNIEnv *env, jobject obj,jint devicetype,    jstring id,jstring ip, jint port, jint sport,jstring username, jstring password,jint start,jint end,jobject logarray,jobject log){     jboolean iscopy;     const char* str_id = (*env)->GetStringUTFChars(env,id,NULL);     const char* str_ip = (*env)->GetStringUTFChars(env,ip,NULL);     const char* str_user = (*env)->GetStringUTFChars(env,username,NULL);     const char* str_pwd = (*env)->GetStringUTFChars(env,password,NULL);     if((str_ip == NULL) || (str_user == NULL) || (str_pwd == NULL))     {        // (*env)->ReleaseCharArrayElements(env,channel,buf,0);         (*env)->ReleaseStringUTFChars(env,id,str_id);         (*env)->ReleaseStringUTFChars(env,ip,str_ip);         (*env)->ReleaseStringUTFChars(env,username,str_user);         (*env)->ReleaseStringUTFChars(env,password,str_pwd);         return (jint)-1;     }    jclass list_cls = (*env)->GetObjectClass(env,logarray);    if(list_cls == NULL)    {        LOGI("GetObjectClass");        return -99;    }    jmethodID list_add = (*env)->GetMethodID(env,list_cls,"add","(Ljava/lang/Object;)Z");    jclass log_cls = (*env)->GetObjectClass(env,log);//FindClass无法找到，原因未知，直接传入类，暂时解决该问题    if(log_cls == NULL)    {        LOGI("GetObjectClass++");        return -99;    }    jmethodID log_costruct = (*env)->GetMethodID(env,log_cls,"<init>","(IIIIIILjava/lang/String;)V");    nc_dev dev;    DeviceInit(&dev,(int)devicetype,str_id,str_ip,(int)port,(int)sport,str_user,str_pwd);    (*env)->ReleaseStringUTFChars(env,id,str_id);    (*env)->ReleaseStringUTFChars(env,ip,str_ip);    (*env)->ReleaseStringUTFChars(env,username,str_user);    (*env)->ReleaseStringUTFChars(env,password,str_pwd);    ptc_logs_t logs;    memset(&logs,0,sizeof(ptc_logs_t));    logs.start_time = (int)start;    logs.end_time = (int)end;    logs.num = 0;    int ret = nc_searchLogs(&dev, &logs);    if(ret < 0)    {        return ret;    }    int i=0;    char str[64];    //LOGE("num = %d",logs.num);//会有溢出的风险    for(i=0;i<logs.num;i++)    {        memset(str,0,64);        snprintf(str,64,"%d.%d.%d.%d",logs.log[i].ip[0],logs.log[i].ip[1],logs.log[i].ip[2],logs.log[i].ip[3]);        //LOGE("%s",str);        //snprintf(str,64,"192.168.0.1");        jstring addr = (*env)->NewStringUTF(env,str);        jobject logobj = (*env)->NewObject(env,log_cls,log_costruct,(jint)logs.log[i].time,(jint)logs.log[i].type,(jint)logs.log[i].sub_type,            (jint)logs.log[i].channel,(jint)logs.log[i].ch_type,(jint)logs.log[i].sub_type2,addr);        (*env)->CallBooleanMethod(env,logarray,list_add,logobj);        (*env)->DeleteLocalRef (env, addr);    }    return logs.num;}*//** * 本地回放线程 */    void localplayback(void* param)    {        playback_t* pbinfo = param;        char* tempbuf = (char*)malloc(500*1024);        ptc_frame_head_t* head = tempbuf;        struct timeval endTime;        struct timeval nowTime;        memset(&endTime,0,sizeof(struct timeval));        memset(&nowTime,0,sizeof(struct timeval));        gettimeofday(&nowTime,NULL);        gettimeofday(&endTime,NULL);        int timeoffreame;        int endFlag = 0;        playback.local_endflag = 0;        while(playback.local_pidflag)        {            if(pbinfo->fd == NULL)                break;            if(feof(pbinfo->fd))                endFlag = 1;            else            {                if(sizeof(ptc_frame_head_t) != fread(head,1,sizeof(ptc_frame_head_t),pbinfo->fd))                {                    //endPlayback();                    if(seekIframe(pbinfo->fd,pbinfo->no) == -2)                    {                        break;                    }                    pbinfo->no++;                    continue;                }                if(head->width*head->height*2 > TEMP_BUF_LEN_PB )                {                    if(seekIframe(pbinfo->fd,pbinfo->no) == -2)                    {                        break;                    }                    pbinfo->no++;                    continue;                }                else if(head->len <= 0 || head->len > 500*1024 - sizeof(ptc_frame_head_t))                {                    if(seekIframe(pbinfo->fd,pbinfo->no) == -2)                    {                        break;                    }                    pbinfo->no++;                    continue;                }                else                {                    if(head->len != fread(tempbuf+sizeof(ptc_frame_head_t),1,head->len,pbinfo->fd))                    {                        LOGE("read data error %d",pbinfo->no);                        //endPlayback();                        if(seekIframe(pbinfo->fd,pbinfo->no) == -2)                        {                            break;                        }                        pbinfo->no++;                        continue;                    }                }            }            if(endFlag == 1)                head->frame_type = 255; //结束            // LOGI("head->frame_rate  %d",head->frame_rate);            // LOGI("start (%d) (%d)",nowTime.tv_sec,nowTime.tv_usec);            //LOGI("end   (%d) (%d)",endTime.tv_sec,endTime.tv_usec);            PlayBackCallback(0,(void*)tempbuf, sizeof(ptc_frame_head_t)+head->len, (void*)pbinfo);            if(head->frame_type == 255)                break;            if(head->frame_type == 1)                pbinfo->no++;            if(head->frame_rate == 0)                head->frame_rate = 25;            if(head->frame_type != 3)                timeoffreame = 1000/head->frame_rate;            else                continue;            gettimeofday(&nowTime,NULL);            if((nowTime.tv_sec - endTime.tv_sec > 1) || (nowTime.tv_sec < endTime.tv_sec))            {            }            else            {                if(nowTime.tv_sec - endTime.tv_sec == 1)                {                    if(((nowTime.tv_usec/1000 + 1000) - endTime.tv_usec/1000) < timeoffreame)                    {                        usleep(timeoffreame*1000 - (nowTime.tv_usec + 1000*1000 - endTime.tv_usec));                    }                }                else                {                    if((nowTime.tv_usec/1000 - endTime.tv_usec/1000) < timeoffreame)                    {                        usleep(timeoffreame*1000 - (nowTime.tv_usec - endTime.tv_usec));                    }                }            }            gettimeofday(&endTime,NULL);        }        free(tempbuf);        playback.local_endflag = 1;        //endPlayback();    }/** * 关闭本地回放 */    JNIEXPORT jint JNICALL Java_com_hdcctv_issmobile_NetApi_LocalRecordPlayEnd(JNIEnv *env, jobject obj)    {        endPlayback();        return (jint)1;    }/** * 开始本地回放 */    JNIEXPORT jint JNICALL Java_com_hdcctv_issmobile_NetApi_LocalRecordPlay(JNIEnv *env, jobject obj,                                                                            jstring dir,jstring name,int starttime)    {        if(g_jvm == 0)        {            (*env)->GetJavaVM(env,&g_jvm);            //env->GetJavaVM(&g_jvm);        }        if(jobj == 0)        {            jobj = (*env)->NewGlobalRef(env,obj);            //jobj = env->NewGlobalRef(obj);        }        const char* name_str = (*env)->GetStringUTFChars(env,name,NULL);        const char* dir_str = (*env)->GetStringUTFChars(env,dir,NULL);        if(name_str == NULL || dir_str == NULL)        {            (*env)->ReleaseStringUTFChars(env,name,name_str);            (*env)->ReleaseStringUTFChars(env,dir,dir_str);        }        PlaybackInit();        char filename[128];        //sprintf(filename,"/mnt/sdcard/tempdata/record/%s",name_str);        sprintf(filename,"%s%s",dir_str,name_str);        playback.fd = fopen(filename,"rb");        (*env)->ReleaseStringUTFChars(env,name,name_str);        (*env)->ReleaseStringUTFChars(env,dir,dir_str);        if(playback.fd == NULL)        {            endPlayback();            return -1;        }        fseek(playback.fd,0,SEEK_SET);        recFileHeader_t fileheard;        if(sizeof(recFileHeader_t) != fread(&fileheard,1,sizeof(recFileHeader_t),playback.fd))        {            endPlayback();            return -1;        }        recTableInfo_t tableinfo;        if(sizeof(recTableInfo_t) != fread(&tableinfo,1,sizeof(recTableInfo_t),playback.fd))        {            endPlayback();            return -1;        }        int offsize = 0;        int i = 0;        for(i=0;i<tableinfo.num;i++)        {            if(tableinfo.item[i].timestamp >= (int)starttime)            {                offsize = tableinfo.item[i].offset;                break;            }        }        playback.no = i;        if(offsize < sizeof(recTableInfo_t)+sizeof(recFileHeader_t))        {            offsize =sizeof(recTableInfo_t)+sizeof(recFileHeader_t);            playback.no = 0;        }        fseek(playback.fd,offsize,SEEK_SET);        if(pthread_mutex_init(&playback.p_lock,NULL)!=0)        {            endPlayback();            return -1;        }        playback.pidflag = 1;        if(pthread_create(&playback.pid,NULL,SendPlayBackVideo,(void*)&playback)!=0)        {            endPlayback();            return -1;        }        playback.local_pidflag = 1;        if(pthread_create(&playback.local_pid,NULL,localplayback,(void*)&playback) != 0)        {            endPlayback();            return -1;        }        return (jint)1;    }    int seekIframe(FILE* fd,int no)    {        fseek(fd,0,SEEK_SET);        recFileHeader_t fileheard;        if(sizeof(recFileHeader_t) != fread(&fileheard,1,sizeof(recFileHeader_t),fd))        {            return -1;        }        recTableInfo_t tableinfo;        if(sizeof(recTableInfo_t) != fread(&tableinfo,1,sizeof(recTableInfo_t),fd))        {            return -1;        }        if(no > tableinfo.num)//末尾            return -2;        int offsize = tableinfo.item[no].offset;        //LOGE("offsize %d",offsize);        //if(offsize < sizeof(recTableInfo_t)+sizeof(recFileHeader_t))        //{        //     return -1;        // }        //LOGE("offsize %d",offsize);        fseek(fd,offsize,SEEK_SET);        return offsize;    }/** * 查看是否有足够录像的空间 */    int clearDir(JNIEnv *env)    {        jclass s_jc = 0;        jmethodID s_jm = 0;        int ret = -1;        s_jc = (*env)->GetObjectClass(env,jobj);        s_jm = (*env)->GetMethodID(env,s_jc, "clearRecord", "()I");        ret = (*env)->CallIntMethod(env,jobj, s_jm);        // ret =  (*env)->CallVoidMethod(env,jobj, s_jm,);        return ret;    }/** * 开始本地录像 */    JNIEXPORT jint JNICALL Java_com_hdcctv_issmobile_NetApi_LocalRecordStart(JNIEnv *env, jobject obj,jint handle,                                                                             jstring ip, jstring name,jint channelnum,jint channelno,jint port,jstring dir)    {        //if(clearDir(env)<0)        //  return -2;        const char* str_name = (*env)->GetStringUTFChars(env,name,NULL);        const char* str_ip = (*env)->GetStringUTFChars(env,ip,NULL);        const char* str_dir = (*env)->GetStringUTFChars(env,dir,NULL);        if((str_ip == NULL) || (str_name == NULL) || (str_dir == NULL))        {            (*env)->ReleaseStringUTFChars(env,ip,str_ip);            (*env)->ReleaseStringUTFChars(env,name,str_name);            return (jint)-1;        }        int i = 0;        for(i = 0;i < AVCODE_NUM;i++)        {            if(av[i].handle == (int)handle)                break;        }        if(i==AVCODE_NUM)        {            (*env)->ReleaseStringUTFChars(env,ip,str_ip);            (*env)->ReleaseStringUTFChars(env,name,str_name);            (*env)->ReleaseStringUTFChars(env,dir,str_dir);            return (jint)-1;        }        memcpy(av[i].recinfo.devAddress,str_ip,sizeof(av[i].recinfo.devAddress));        memcpy(av[i].recinfo.devName,str_name,sizeof(av[i].recinfo.devName));        av[i].recinfo.devChannelNum = (int)channelnum;        av[i].recinfo.channelNo = (int) channelno;        av[i].recinfo.devPort = (int)port;        av[i].recinfo.begTime = 0;        av[i].recinfo.endTime = 0;        av[i].recinfo.max = MAX_RECTABLEITEM;        av[i].recinfo.num = -1;        av[i].recinfo.ver = 1;        /*  if(access("/mnt/sdcard/tempdata/record/",0) ==1)            {                 mkdir("/mnt/sdcard/tempdata/record/",0777);            }*/        //snprintf(av[i].recname,sizeof(av[i].recname),"/mnt/sdcard/tempdata/image/%s-%d-%d.rec",av[i].recinfo.devAddress,av[i].recinfo.devPort,av[i].recinfo.channelNo);        //sprintf(av[i].recname,"/mnt/sdcard/tempdata/record/%s-%d-%d.rec",av[i].recinfo.devAddress,av[i].recinfo.devPort,av[i].recinfo.channelNo);        sprintf(av[i].recname,"%s%s-%d-%d",str_dir,av[i].recinfo.devAddress,av[i].recinfo.devPort,av[i].recinfo.channelNo);        LOGI("name = %s",av[i].recname);        (*env)->ReleaseStringUTFChars(env,ip,str_ip);        (*env)->ReleaseStringUTFChars(env,name,str_name);        (*env)->ReleaseStringUTFChars(env,dir,str_dir);        av[i].fd = NULL;        av[i].fd = fopen(av[i].recname,"wb");        if(av[i].fd == NULL)        {            return (jint)-1;        }        av[i].recflag = 1;        av[i].first_flag = 0;        //nc_forceRtsKeyFrame(handle);        return (jint)0;    }/** * 本地录像回调 */    void localRecord(av_t* av,void* data)    {        ptc_frame_head_t* frameInfo = (ptc_frame_head_t*)data;        int head_len = sizeof(ptc_frame_head_t);        if(av->first_flag == 0)        {            av->first_flag = 1;            av->last_time = frameInfo->sec;        }        if(abs(av->last_time - frameInfo->sec) > MAX_INTERVAl)        {            localRecordstop(av->handle,0);            av->fd = fopen(av->recname,"wb");            if(av->fd == NULL)            {                av->recflag = 0;                return ;            }            av->recinfo.num = -1;        }        av->last_time = frameInfo->sec;        if(frameInfo->frame_type == 1)        {            av->recinfo.endTime = frameInfo->sec;            if(av->recinfo.num == -1)            {                av->recinfo.begTime = frameInfo->sec;                if(fseek(av->fd,sizeof(recFileHeader_t)+sizeof(recTableInfo_t),SEEK_SET) != 0)                    return;            }            if(av->recinfo.num >= MAX_RECTABLEITEM -1)            {                localRecordstop(av->handle,0);                av->fd = fopen(av->recname,"wb");                if(av->fd == NULL)                {                    av->recflag = 0;                    return ;                }                av->recinfo.num = -1;            }            av->recinfo.num++;            av->recinfo.item[av->recinfo.num].no = av->recinfo.num;            av->recinfo.item[av->recinfo.num].frame_rate = frameInfo->frame_rate;            av->recinfo.item[av->recinfo.num].offset = ftell(av->fd);            av->recinfo.item[av->recinfo.num].size = sizeof(ptc_frame_head_t)+frameInfo->len;            av->recinfo.item[av->recinfo.num].timestamp = frameInfo->sec;        }        if(av->recinfo.num >= 0)        {            fwrite((char*)data,1,sizeof(ptc_frame_head_t)+frameInfo->len,av->fd);            // LOGI("width %d height %d len %d type %d",frameInfo->width,frameInfo->height,frameInfo->len,frameInfo->frame_type);        }    }    void localRecordstop(int handle,int flag)    {        int i = 0;        for(i = 0;i < AVCODE_NUM;i++)        {            if(av[i].handle == (int)handle)                break;        }        if(i==AVCODE_NUM)            return ;        if(av[i].fd == NULL)            return;        if(flag == 1)            av[i].recflag = 0;        if((av[i].recinfo.num < 0) || (av[i].recinfo.begTime == 0) || (av[i].recinfo.endTime == 0) || (av[i].recinfo.begTime >= av[i].recinfo.endTime))        {            fclose(av[i].fd);            av[i].fd = NULL;            remove(av[i].recname);        }        else        {            fseek(av[i].fd,0,SEEK_SET);            recFileHeader_t fileInfo;            fileInfo.type = 123;            fileInfo.size = 456;            fileInfo.version = 789;            memcpy(fileInfo.describe,"123456789",64);            fwrite(&fileInfo,1,sizeof(recFileHeader_t),av[i].fd);            av[i].recinfo.num++;            fwrite(&av[i].recinfo,1,sizeof(recTableInfo_t),av[i].fd);            fclose(av[i].fd);            char newname[128];            //sprintf(newname,"/mnt/sdcard/tempdata/record/%s-%d-%d-%d-%d.rec",av[i].recinfo.devAddress,av[i].recinfo.devPort,av[i].recinfo.channelNo,av[i].recinfo.begTime,av[i].recinfo.endTime);            sprintf(newname,"%s-%d-%d.rec",av[i].recname,av[i].recinfo.begTime,av[i].recinfo.endTime);            int ret = -1;            ret = rename(av[i].recname,newname);            if(ret < 0)                LOGI("rename error");        }        if(flag)        {            memset(&av[i].recinfo,0,sizeof(av[i].recinfo));            memset(av[i].recname,0,128);            av[i].recinfo.num = -1;        }    }/** * 停止本地录像 */    JNIEXPORT jint JNICALL Java_com_hdcctv_issmobile_NetApi_LocalRecordEnd(JNIEnv *env, jobject obj,jint handle)    {        localRecordstop((int)handle,1);        return (jint)0;    }/** * 同步时间 */    JNIEXPORT jint JNICALL Java_com_hdcctv_issmobile_NetApi_SyncTime(JNIEnv *env, jobject obj,jint devicetype,                                                                     jstring id,jstring ip, jint port,jint sport, jstring username, jstring password,jint utc_sec,int zone,int dst_hour)    {        jboolean iscopy;        const char* str_id = (*env)->GetStringUTFChars(env,id,NULL);        const char* str_ip = (*env)->GetStringUTFChars(env,ip,NULL);        const char* str_user = (*env)->GetStringUTFChars(env,username,NULL);        const char* str_pwd = (*env)->GetStringUTFChars(env,password,NULL);        if((str_ip == NULL) || (str_user == NULL) || (str_pwd == NULL))        {            (*env)->ReleaseStringUTFChars(env,id,str_id);            (*env)->ReleaseStringUTFChars(env,ip,str_ip);            (*env)->ReleaseStringUTFChars(env,username,str_user);            (*env)->ReleaseStringUTFChars(env,password,str_pwd);            return (jint)-1;        }        nc_dev dev;        DeviceInit(&dev,(int)devicetype,str_id,str_ip,(int)port,(int)sport,str_user,str_pwd);        int ret = nc_syncTime(&dev, (unsigned int)utc_sec, (int)zone, (int)dst_hour);        (*env)->ReleaseStringUTFChars(env,id,str_id);        (*env)->ReleaseStringUTFChars(env,ip,str_ip);        (*env)->ReleaseStringUTFChars(env,username,str_user);        (*env)->ReleaseStringUTFChars(env,password,str_pwd);        return ret;    }    void AvInit(av_t* av,int stream)    {        av->handle = -1;        av->live = 1;        av->status = 0;        av->vd_handle = 0;        if(stream == 0)//主码流        {            av->mInitLen = TEMP_BUF_LEN_MAIN;            av->tempbuf = (char*)malloc(TEMP_BUF_LEN_MAIN);        }        else//子码流        {            av->mInitLen = TEMP_BUF_LEN_SUB;            av->tempbuf = (char*)malloc(TEMP_BUF_LEN_SUB);        }        av->audiobuf = (char*)malloc(AUDIO_BUF_LEN);        av->adstate = adpcm_begin();        av->width = 0;        av->height = 0;        av->frame_sub_type = 0;        av->Iframe_flag = 0;        av->tempbuf_len = 0;        av->raw_len = 0;        av->tick = tick;        av->frame_num = 0;        av->flag = 0;        av->audio_len = 0;        av->audio_tick = tick;        av->sec = 0;        av->usec = 0;        av->pidflag = 1;        av->pbflag = 0;        av->recflag = 0;        eventx_init(&av->event);    }    void AvDone(av_t *av)    {        nc_stopRts(av->handle);        av->handle = -1;        av->pidflag = 0;        eventx_post(&av->event);//加快线程退出        pthread_join(av->pid,NULL);        while(av->flag != 0 || av->pbflag != 0)        {            usleep(50*1000);        }        eventx_unit(&av->event);        pthread_mutex_destroy(&av->v_lock);        if(av->vd_handle != 0)        {            video_ended(&av->vd_handle);        }        if(av->tempbuf != NULL)        {            free(av->tempbuf);            av->tempbuf = NULL;        }        if(av->audiobuf != NULL)        {            free(av->audiobuf);            av->audiobuf = NULL;        }        if(av->adstate != NULL)        {            adpcm_end(av->adstate);            av->adstate = NULL;        }        if(av->fd != NULL)        {            fclose(av->fd);            av->fd = NULL;        }        av->live = 0;        av->width = 0;        av->height = 0;        av->tempbuf_len = 0;        av->frame_sub_type = 0;        av->Iframe_flag = 0;        av->raw_len = 0;        av->tick = -1;        av->frame_num = 0;        av->recflag = 0;    }    void PlaybackInit()    {        playback.vd_handle = 0;        playback.adstate = adpcm_begin();        playback.tempbuf = (char*)malloc(TEMP_BUF_LEN_PB);        playback.audiobuf = (char*)malloc(AUDIO_BUF_LEN);        playback.width = 0;        playback.height = 0;        playback.status = 0;        playback.frame_sub_type = 0;        playback.sec = 0;        playback.usec = 0;        playback.audio_len = 0;        playback.audio_tick = tick;        playback.handle = -1;        playback.pid = -1;        playback.pbflag = 0;        playback.raw_len = 0;        playback.tempbuf_len = 0;        playback.tick = tick;        playback.flag = 0;        playback.frame_num = 0;        playback.local_endflag = 1;        playback.fd = NULL;        playback.no = -1;        eventx_init(&playback.event);    }/** * 初始化nc_dev结构体 */    void DeviceInit(nc_dev* dev,int devicetype,char* str_id,char* str_ip,int port,int sport,char* str_user, char* str_pwd)    {        switch(devicetype)        {            case 0:                dev->ptc = NC_PTC_Qihan;                break;            case 1:                dev->ptc = NC_PTC_HuaYi;                break;            case 2:                //LOGE("NC_PTC_YuShi");                dev->ptc = NC_PTC_YuShi;                break;            case 3:                //LOGE("NC_PTC_YuShi_Cloud");                dev->ptc = NC_PTC_YuShi_Cloud;                break;            case 4:                dev->ptc = NC_PTC_QiHan_Cloud;                break;            case 5:                dev->ptc = NC_PTC_XiongMai;                break;            default :                dev->ptc = NC_PTC_Qihan;                break;        }        strncpy(dev->dev_id,str_id,sizeof(dev->dev_id));        strncpy(dev->ip,str_ip,sizeof(dev->ip));        dev->msg_port = (int)port;        dev->stream_port = sport;        strncpy(dev->user,str_user,sizeof(dev->user));        strncpy(dev->pswd,str_pwd,sizeof(dev->pswd));        /*    memcpy(dev->dev_id,str_id,sizeof(dev->dev_id));//在部分手机上有反馈回错误Native crash            memcpy(dev->ip,str_ip,sizeof(dev->ip));            dev->msg_port = (int)port;            dev->stream_port = sport;            memcpy(dev->user,str_user,sizeof(dev->user));            memcpy(dev->pswd,str_pwd,sizeof(dev->pswd));*/        /*   LOGE("id=%s",dev->dev_id);           LOGE("ip=%s",dev->ip);           LOGE("msg_port=%d",dev->msg_port);           LOGE("stream_port=%d",dev->stream_port);           LOGE("user=%s",dev->user);           LOGE("pswd=%s",dev->pswd);*/    }    pthread_t tickpid2;    int pid2Flag = 0;    void PushCallBack(int lLiveHandle, void *data, unsigned int len, void *pUser)    {        hdcctv_qpns_alarm_t* alarm = (hdcctv_qpns_alarm_t*)data;        // LOGE("no%d id(%s) time(%d) type(%d) channel(%d)",alarm->no,alarm->dev_id,alarm->time,alarm->type,alarm->channel);        int ch=0;        int i=0;        for(i=0;i<32;i++)        {            if((alarm->channel & (1<<i)) != 0)            {                ch = i;                break;            }        }        int userid = 0;        int type = 1;        JNIEnv* env = 0;        (*g_jvm)->AttachCurrentThread(g_jvm,&env,NULL);        static jclass s_jc = 0;        static jmethodID s_jm = 0;        if (env != 0)        {            if(s_jc == 0)            {                s_jc = (*env)->GetObjectClass(env,jobj);            }            if(s_jm == 0)            {                s_jm = (*env)->GetMethodID(env,s_jc, "showAlarm", "(ILjava/lang/String;III)V");            }            if(s_jm != 0)            {                jstring str_alarmid = (*env)->NewStringUTF(env, alarm->dev_id);                (*env)->CallVoidMethod(env,jobj, s_jm, (jint)alarm->no,str_alarmid,(jint)alarm->time,(jint)ch,(jint)alarm->type);                (*env)->DeleteLocalRef (env, str_alarmid);            }        }        (*g_jvm)->DetachCurrentThread(g_jvm);    }    JNIEXPORT jint JNICALL Java_com_hdcctv_issmobile_NetApi_StartPush(JNIEnv *env, jobject obj,jstring token)    {        if(g_jvm == 0)        {            (*env)->GetJavaVM(env,&g_jvm);            //env->GetJavaVM(&g_jvm);        }        if(jobj == 0)        {            jobj = (*env)->NewGlobalRef(env,obj);            //jobj = env->NewGlobalRef(obj);        }        const char* str_token = (*env)->GetStringUTFChars(env,token,NULL);        // pid2Flag = 1;        //pthread_create(&tickpid2,NULL,(void*)TickThread2,NULL);        //LOGE("pid === %d",tickpid2);        int ret = -1;        ret = nc_startQpns(HDCCTV_QPNS_TOKEN_TYPE_ANDROID, str_token,HDCCTV_LANUAGE_EN, PushCallBack, NULL);        LOGE("nc_startQpns+++++++++++++");        (*env)->ReleaseStringUTFChars(env,token,str_token);        return ret;    }    JNIEXPORT jint JNICALL Java_com_hdcctv_issmobile_NetApi_StopPush(JNIEnv *env, jobject obj)    {        nc_stopQpns();        return 0;    }    JNIEXPORT jint JNICALL Java_com_hdcctv_issmobile_NetApi_GetPushDevices(JNIEnv *env, jobject obj,jstring token,jobject devices,jobject info)    {        const char* str_token = (*env)->GetStringUTFChars(env,token,NULL);        if(str_token == NULL)        {            (*env)->ReleaseStringUTFChars(env,token,str_token);            return -99;        }        jclass list_cls = (*env)->GetObjectClass(env,devices);        if(list_cls == NULL)        {            LOGI("GetObjectClass");            (*env)->ReleaseStringUTFChars(env,token,str_token);            return -99;        }        jmethodID list_add = (*env)->GetMethodID(env,list_cls,"add","(Ljava/lang/Object;)Z");        jclass info_cls = (*env)->GetObjectClass(env,info);//FindClass无法找到，原因未知，直接传入类，暂时解决该问题        if(info_cls == NULL)        {            LOGI("GetObjectClass++");            (*env)->ReleaseStringUTFChars(env,token,str_token);            return -99;        }        jmethodID info_costruct = (*env)->GetMethodID(env,info_cls,"<init>","(IIIILjava/lang/String;)V");        hdcctv_qpns_device_maps_t device_map;        memset(&device_map,0,sizeof(hdcctv_qpns_device_maps_t));        int ret = -1;        ret = nc_getQpnsDeviceMaps(HDCCTV_QPNS_TOKEN_TYPE_ANDROID,str_token,&device_map);        if(ret <0)        {            (*env)->ReleaseStringUTFChars(env,token,str_token);            return ret;        }        int i = 0;        for(i=0;i<device_map.num;i++)        {            jstring id = (*env)->NewStringUTF(env,device_map.device_map[i].dev_id);            jobject infoobj = (*env)->NewObject(env,info_cls,info_costruct,(jint)device_map.device_map[i].push_count,(jint)device_map.device_map[i].success_count,                                                (jint)device_map.device_map[i].fail_count,(jint)device_map.device_map[i].last_time,id);            (*env)->CallBooleanMethod(env,devices,list_add,infoobj);            (*env)->DeleteLocalRef (env, id);        };        return ret;    }    JNIEXPORT jint JNICALL Java_com_hdcctv_issmobile_NetApi_AddPushDevice(JNIEnv *env, jobject obj,jstring token,jstring id)    {        const char* str_token = (*env)->GetStringUTFChars(env,token,NULL);        const char* str_id = (*env)->GetStringUTFChars(env,id,NULL);        if(str_token == NULL || str_id == NULL)        {            (*env)->ReleaseStringUTFChars(env,token,str_token);            (*env)->ReleaseStringUTFChars(env,id,str_id);            return -99;        }        hdcctv_qpns_device_maps_t device_map;        memset(&device_map,0,sizeof(hdcctv_qpns_device_maps_t));        device_map.num = 1;        snprintf(device_map.device_map[0].dev_id,HDCCTV_QPNS_TOKEN_SIZE,str_id);        snprintf(device_map.device_map[0].token,HDCCTV_QPNS_TOKEN_SIZE,str_token);        //LOGE("token = %s",device_map.device_map[0].token);        int ret = -1;        ret = nc_addQpnsDeviceMaps(HDCCTV_QPNS_TOKEN_TYPE_ANDROID,str_token,&device_map);        (*env)->ReleaseStringUTFChars(env,token,str_token);        (*env)->ReleaseStringUTFChars(env,id,str_id);        return ret;    }    JNIEXPORT jint JNICALL Java_com_hdcctv_issmobile_NetApi_DelPushDevice(JNIEnv *env, jobject obj,jstring token,jstring id)    {        const char* str_token = (*env)->GetStringUTFChars(env,token,NULL);        const char* str_id = (*env)->GetStringUTFChars(env,id,NULL);        if(str_token == NULL || str_id == NULL)        {            (*env)->ReleaseStringUTFChars(env,token,str_token);            (*env)->ReleaseStringUTFChars(env,id,str_id);            return -99;        }        hdcctv_qpns_device_maps_t device_map;        memset(&device_map,0,sizeof(hdcctv_qpns_device_maps_t));        device_map.num = 1;        snprintf(device_map.device_map[0].dev_id,HDCCTV_QPNS_TOKEN_SIZE,str_id);        snprintf(device_map.device_map[0].token,HDCCTV_QPNS_TOKEN_SIZE,str_token);        device_map.device_map[0].token_type = HDCCTV_QPNS_TOKEN_TYPE_ANDROID;        //LOGE("aaaatoken = %s",device_map.device_map[0].token);        int ret = -1;        ret = nc_delQpnsDeviceMaps(HDCCTV_QPNS_TOKEN_TYPE_ANDROID,str_token,&device_map);        (*env)->ReleaseStringUTFChars(env,token,str_token);        (*env)->ReleaseStringUTFChars(env,id,str_id);        return ret;    }/** * 注册时获取短信验证码 */    JNIEXPORT jint JNICALL Java_com_hdcctv_issmobile_NetApi_GetSmsReg(JNIEnv *env, jobject obj,jobject config)    {        jclass info_cls = (*env)->GetObjectClass(env,config);//FindClass无法找到，原因未知，直接传入类，暂时解决该问题        if(info_cls == NULL)        {            LOGI("GetObjectClasseee");            return -99;        }        jfieldID user_FiledId = (*env)->GetFieldID(env,info_cls,"username","Ljava/lang/String;");        jfieldID pswd_FiledId = (*env)->GetFieldID(env,info_cls,"password","Ljava/lang/String;");        jfieldID mobile_FiledId = (*env)->GetFieldID(env,info_cls,"mobile","Ljava/lang/String;");        jfieldID email_FiledId = (*env)->GetFieldID(env,info_cls,"email","Ljava/lang/String;");        jfieldID local_FiledId = (*env)->GetFieldID(env,info_cls,"location","I");        if(user_FiledId == NULL || pswd_FiledId == NULL           || mobile_FiledId == NULL || email_FiledId == NULL || local_FiledId == NULL)        {            return -99;        }        jint jlocation = (jint)(*env)->GetIntField(env,config ,local_FiledId);        jstring jusername = (jstring)(*env)->GetObjectField(env,config ,user_FiledId);        jstring jpassword = (jstring)(*env)->GetObjectField(env,config ,pswd_FiledId);        jstring jmobile = (jstring)(*env)->GetObjectField(env,config ,mobile_FiledId);        jstring jemail = (jstring)(*env)->GetObjectField(env,config ,email_FiledId);        const char* cusername = (*env)->GetStringUTFChars(env,jusername, NULL);        const char* cpassword = (*env)->GetStringUTFChars(env,jpassword, NULL);        const char* cmobile = (*env)->GetStringUTFChars(env,jmobile, NULL);        const char* cemail = (*env)->GetStringUTFChars(env,jemail, NULL);        hdcctv_cloud_user_t cloud_user;        memset(&cloud_user,0,sizeof(hdcctv_cloud_user_t));        memcpy(cloud_user.username,cusername,sizeof(cloud_user.username));        memcpy(cloud_user.password,cpassword,sizeof(cloud_user.password));        memcpy(cloud_user.mobile,cmobile,sizeof(cloud_user.mobile));        memcpy(cloud_user.email,cemail,sizeof(cloud_user.email));        if((int)jlocation == 1)            cloud_user.location = HDCCTV_LOCATION_CN;        else            cloud_user.location = HDCCTV_LOCATION_US;        (*env)->ReleaseStringUTFChars(env,jusername,cusername);        (*env)->ReleaseStringUTFChars(env,jpassword,cpassword);        (*env)->ReleaseStringUTFChars(env,jmobile,cmobile);        (*env)->ReleaseStringUTFChars(env,jemail,cemail);        int ret = nc_getSms_reg(&cloud_user);        return (jint)ret;    }/* * 注册用户 */    JNIEXPORT jint JNICALL Java_com_hdcctv_issmobile_NetApi_UserReg(JNIEnv *env, jobject obj,jobject config,jstring jcode)    {        const char* ccode = (*env)->GetStringUTFChars(env,jcode, NULL);        if(ccode == NULL)        {            (*env)->ReleaseStringUTFChars(env,jcode,ccode);            return -99;        }        jclass info_cls = (*env)->GetObjectClass(env,config);//FindClass无法找到，原因未知，直接传入类，暂时解决该问题        if(info_cls == NULL)        {            LOGI("GetObjectClasseee");            return -99;        }        jfieldID user_FiledId = (*env)->GetFieldID(env,info_cls,"username","Ljava/lang/String;");        jfieldID pswd_FiledId = (*env)->GetFieldID(env,info_cls,"password","Ljava/lang/String;");        jfieldID mobile_FiledId = (*env)->GetFieldID(env,info_cls,"mobile","Ljava/lang/String;");        jfieldID email_FiledId = (*env)->GetFieldID(env,info_cls,"email","Ljava/lang/String;");        jfieldID local_FiledId = (*env)->GetFieldID(env,info_cls,"location","I");        if(user_FiledId == NULL || pswd_FiledId == NULL           || mobile_FiledId == NULL || email_FiledId == NULL || local_FiledId == NULL)        {            return -99;        }        jint jlocation = (jint)(*env)->GetIntField(env,config ,local_FiledId);        jstring jusername = (jstring)(*env)->GetObjectField(env,config ,user_FiledId);        jstring jpassword = (jstring)(*env)->GetObjectField(env,config ,pswd_FiledId);        jstring jmobile = (jstring)(*env)->GetObjectField(env,config ,mobile_FiledId);        jstring jemail = (jstring)(*env)->GetObjectField(env,config ,email_FiledId);        const char* cusername = (*env)->GetStringUTFChars(env,jusername, NULL);        const char* cpassword = (*env)->GetStringUTFChars(env,jpassword, NULL);        const char* cmobile = (*env)->GetStringUTFChars(env,jmobile, NULL);        const char* cemail = (*env)->GetStringUTFChars(env,jemail, NULL);        hdcctv_cloud_user_t cloud_user;        memset(&cloud_user,0,sizeof(hdcctv_cloud_user_t));        memcpy(cloud_user.username,cusername,sizeof(cloud_user.username));        memcpy(cloud_user.password,cpassword,sizeof(cloud_user.password));        memcpy(cloud_user.mobile,cmobile,sizeof(cloud_user.mobile));        memcpy(cloud_user.email,cemail,sizeof(cloud_user.email));        if((int)jlocation == 1)            cloud_user.location = HDCCTV_LOCATION_CN;        else            cloud_user.location = HDCCTV_LOCATION_US;        (*env)->ReleaseStringUTFChars(env,jusername,cusername);        (*env)->ReleaseStringUTFChars(env,jpassword,cpassword);        (*env)->ReleaseStringUTFChars(env,jmobile,cmobile);        (*env)->ReleaseStringUTFChars(env,jemail,cemail);        int ret = nc_regUser(&cloud_user, ccode);        (*env)->ReleaseStringUTFChars(env,jcode,ccode);        return (jint)ret;    }/* * 修改密码 */    JNIEXPORT jint JNICALL Java_com_hdcctv_issmobile_NetApi_ChangePswd(JNIEnv *env, jobject obj,jobject config,jstring pswd)    {        const char* new_pswd = (*env)->GetStringUTFChars(env,pswd, NULL);        if(new_pswd == NULL)        {            (*env)->ReleaseStringUTFChars(env,pswd,new_pswd);            return -99;        }        jclass info_cls = (*env)->GetObjectClass(env,config);//FindClass无法找到，原因未知，直接传入类，暂时解决该问题        if(info_cls == NULL)        {            LOGI("GetObjectClasseee");            return -99;        }        jfieldID user_FiledId = (*env)->GetFieldID(env,info_cls,"username","Ljava/lang/String;");        jfieldID pswd_FiledId = (*env)->GetFieldID(env,info_cls,"password","Ljava/lang/String;");        jfieldID mobile_FiledId = (*env)->GetFieldID(env,info_cls,"mobile","Ljava/lang/String;");        jfieldID email_FiledId = (*env)->GetFieldID(env,info_cls,"email","Ljava/lang/String;");        jfieldID local_FiledId = (*env)->GetFieldID(env,info_cls,"location","I");        if(user_FiledId == NULL || pswd_FiledId == NULL           || mobile_FiledId == NULL || email_FiledId == NULL || local_FiledId == NULL)        {            return -99;        }        jint jlocation = (jint)(*env)->GetIntField(env,config ,local_FiledId);        jstring jusername = (jstring)(*env)->GetObjectField(env,config ,user_FiledId);        jstring jpassword = (jstring)(*env)->GetObjectField(env,config ,pswd_FiledId);        jstring jmobile = (jstring)(*env)->GetObjectField(env,config ,mobile_FiledId);        jstring jemail = (jstring)(*env)->GetObjectField(env,config ,email_FiledId);        const char* cusername = (*env)->GetStringUTFChars(env,jusername, NULL);        const char* cpassword = (*env)->GetStringUTFChars(env,jpassword, NULL);        const char* cmobile = (*env)->GetStringUTFChars(env,jmobile, NULL);        const char* cemail = (*env)->GetStringUTFChars(env,jemail, NULL);        hdcctv_cloud_user_t cloud_user;        memset(&cloud_user,0,sizeof(hdcctv_cloud_user_t));        memcpy(cloud_user.username,cusername,sizeof(cloud_user.username));        memcpy(cloud_user.password,cpassword,sizeof(cloud_user.password));        memcpy(cloud_user.mobile,cmobile,sizeof(cloud_user.mobile));        memcpy(cloud_user.email,cemail,sizeof(cloud_user.email));        if((int)jlocation == 1)            cloud_user.location = HDCCTV_LOCATION_CN;        else            cloud_user.location = HDCCTV_LOCATION_US;        (*env)->ReleaseStringUTFChars(env,jusername,cusername);        (*env)->ReleaseStringUTFChars(env,jpassword,cpassword);        (*env)->ReleaseStringUTFChars(env,jmobile,cmobile);        (*env)->ReleaseStringUTFChars(env,jemail,cemail);        int ret = nc_setPswd(&cloud_user, new_pswd);        (*env)->ReleaseStringUTFChars(env,pswd,new_pswd);        return (jint)ret;    }/** * 修改密码时获取短信验证码 */    JNIEXPORT jint JNICALL Java_com_hdcctv_issmobile_NetApi_GetSmsPswd(JNIEnv *env, jobject obj,jobject config)    {        jclass info_cls = (*env)->GetObjectClass(env,config);//FindClass无法找到，原因未知，直接传入类，暂时解决该问题        if(info_cls == NULL)        {            LOGI("GetObjectClasseee");            return -99;        }        jfieldID user_FiledId = (*env)->GetFieldID(env,info_cls,"username","Ljava/lang/String;");        jfieldID pswd_FiledId = (*env)->GetFieldID(env,info_cls,"password","Ljava/lang/String;");        jfieldID mobile_FiledId = (*env)->GetFieldID(env,info_cls,"mobile","Ljava/lang/String;");        jfieldID email_FiledId = (*env)->GetFieldID(env,info_cls,"email","Ljava/lang/String;");        jfieldID local_FiledId = (*env)->GetFieldID(env,info_cls,"location","I");        if(user_FiledId == NULL || pswd_FiledId == NULL           || mobile_FiledId == NULL || email_FiledId == NULL || local_FiledId == NULL)        {            return -99;        }        jint jlocation = (jint)(*env)->GetIntField(env,config ,local_FiledId);        jstring jusername = (jstring)(*env)->GetObjectField(env,config ,user_FiledId);        jstring jpassword = (jstring)(*env)->GetObjectField(env,config ,pswd_FiledId);        jstring jmobile = (jstring)(*env)->GetObjectField(env,config ,mobile_FiledId);        jstring jemail = (jstring)(*env)->GetObjectField(env,config ,email_FiledId);        const char* cusername = (*env)->GetStringUTFChars(env,jusername, NULL);        const char* cpassword = (*env)->GetStringUTFChars(env,jpassword, NULL);        const char* cmobile = (*env)->GetStringUTFChars(env,jmobile, NULL);        const char* cemail = (*env)->GetStringUTFChars(env,jemail, NULL);        hdcctv_cloud_user_t cloud_user;        memset(&cloud_user,0,sizeof(hdcctv_cloud_user_t));        memcpy(cloud_user.username,cusername,sizeof(cloud_user.username));        memcpy(cloud_user.password,cpassword,sizeof(cloud_user.password));        memcpy(cloud_user.mobile,cmobile,sizeof(cloud_user.mobile));        memcpy(cloud_user.email,cemail,sizeof(cloud_user.email));        if((int)jlocation == 1)            cloud_user.location = HDCCTV_LOCATION_CN;        else            cloud_user.location = HDCCTV_LOCATION_US;        (*env)->ReleaseStringUTFChars(env,jusername,cusername);        (*env)->ReleaseStringUTFChars(env,jpassword,cpassword);        (*env)->ReleaseStringUTFChars(env,jmobile,cmobile);        (*env)->ReleaseStringUTFChars(env,jemail,cemail);        int ret = nc_getSms_pswd(&cloud_user);        return (jint)ret;    }/* * 重置密码 */    JNIEXPORT jint JNICALL Java_com_hdcctv_issmobile_NetApi_ResetPswd(JNIEnv *env, jobject obj,jobject config,jstring code)    {        const char* check_code = (*env)->GetStringUTFChars(env,code, NULL);        if(check_code == NULL)        {            (*env)->ReleaseStringUTFChars(env,code,check_code);            return -99;        }        jclass info_cls = (*env)->GetObjectClass(env,config);//FindClass无法找到，原因未知，直接传入类，暂时解决该问题        if(info_cls == NULL)        {            LOGI("GetObjectClasseee");            return -99;        }        jfieldID user_FiledId = (*env)->GetFieldID(env,info_cls,"username","Ljava/lang/String;");        jfieldID pswd_FiledId = (*env)->GetFieldID(env,info_cls,"password","Ljava/lang/String;");        jfieldID mobile_FiledId = (*env)->GetFieldID(env,info_cls,"mobile","Ljava/lang/String;");        jfieldID email_FiledId = (*env)->GetFieldID(env,info_cls,"email","Ljava/lang/String;");        jfieldID local_FiledId = (*env)->GetFieldID(env,info_cls,"location","I");        if(user_FiledId == NULL || pswd_FiledId == NULL           || mobile_FiledId == NULL || email_FiledId == NULL || local_FiledId == NULL)        {            return -99;        }        jint jlocation = (jint)(*env)->GetIntField(env,config ,local_FiledId);        jstring jusername = (jstring)(*env)->GetObjectField(env,config ,user_FiledId);        jstring jpassword = (jstring)(*env)->GetObjectField(env,config ,pswd_FiledId);        jstring jmobile = (jstring)(*env)->GetObjectField(env,config ,mobile_FiledId);        jstring jemail = (jstring)(*env)->GetObjectField(env,config ,email_FiledId);        const char* cusername = (*env)->GetStringUTFChars(env,jusername, NULL);        const char* cpassword = (*env)->GetStringUTFChars(env,jpassword, NULL);        const char* cmobile = (*env)->GetStringUTFChars(env,jmobile, NULL);        const char* cemail = (*env)->GetStringUTFChars(env,jemail, NULL);        hdcctv_cloud_user_t cloud_user;        memset(&cloud_user,0,sizeof(hdcctv_cloud_user_t));        memcpy(cloud_user.username,cusername,sizeof(cloud_user.username));        memcpy(cloud_user.password,cpassword,sizeof(cloud_user.password));        memcpy(cloud_user.mobile,cmobile,sizeof(cloud_user.mobile));        memcpy(cloud_user.email,cemail,sizeof(cloud_user.email));        if((int)jlocation == 1)            cloud_user.location = HDCCTV_LOCATION_CN;        else            cloud_user.location = HDCCTV_LOCATION_US;        (*env)->ReleaseStringUTFChars(env,jusername,cusername);        (*env)->ReleaseStringUTFChars(env,jpassword,cpassword);        (*env)->ReleaseStringUTFChars(env,jmobile,cmobile);        (*env)->ReleaseStringUTFChars(env,jemail,cemail);        int ret = nc_resetPswd(&cloud_user, check_code);        (*env)->ReleaseStringUTFChars(env,code,check_code);        return (jint)ret;    }/* * 登陆云 */    JNIEXPORT jint JNICALL Java_com_hdcctv_issmobile_NetApi_CloudUserLogin(JNIEnv *env, jobject obj,jobject user)    {        jclass info_cls = (*env)->GetObjectClass(env,user);        if(info_cls == NULL)        {            LOGI("GetObjectClasseee");            return -99;        }        jfieldID user_FiledId = (*env)->GetFieldID(env,info_cls,"username","Ljava/lang/String;");        jfieldID pswd_FiledId = (*env)->GetFieldID(env,info_cls,"password","Ljava/lang/String;");        jfieldID mobile_FiledId = (*env)->GetFieldID(env,info_cls,"mobile","Ljava/lang/String;");        jfieldID email_FiledId = (*env)->GetFieldID(env,info_cls,"email","Ljava/lang/String;");        jfieldID local_FiledId = (*env)->GetFieldID(env,info_cls,"location","I");        if(user_FiledId == NULL || pswd_FiledId == NULL           || mobile_FiledId == NULL || email_FiledId == NULL || local_FiledId == NULL)        {            return -99;        }        jint jlocation = (jint)(*env)->GetIntField(env,user ,local_FiledId);        jstring jusername = (jstring)(*env)->GetObjectField(env,user ,user_FiledId);        jstring jpassword = (jstring)(*env)->GetObjectField(env,user ,pswd_FiledId);        jstring jmobile = (jstring)(*env)->GetObjectField(env,user ,mobile_FiledId);        jstring jemail = (jstring)(*env)->GetObjectField(env,user ,email_FiledId);        const char* cusername = (*env)->GetStringUTFChars(env,jusername, NULL);        const char* cpassword = (*env)->GetStringUTFChars(env,jpassword, NULL);        const char* cmobile = (*env)->GetStringUTFChars(env,jmobile, NULL);        const char* cemail = (*env)->GetStringUTFChars(env,jemail, NULL);        hdcctv_cloud_user_t cloud_user;        memset(&cloud_user,0,sizeof(hdcctv_cloud_user_t));        memcpy(cloud_user.username,cusername,sizeof(cloud_user.username));        memcpy(cloud_user.password,cpassword,sizeof(cloud_user.password));        memcpy(cloud_user.mobile,cmobile,sizeof(cloud_user.mobile));        memcpy(cloud_user.email,cemail,sizeof(cloud_user.email));        if((int)jlocation == 1)            cloud_user.location = HDCCTV_LOCATION_CN;        else            cloud_user.location = HDCCTV_LOCATION_US;        (*env)->ReleaseStringUTFChars(env,jusername,cusername);        (*env)->ReleaseStringUTFChars(env,jpassword,cpassword);        (*env)->ReleaseStringUTFChars(env,jmobile,cmobile);        (*env)->ReleaseStringUTFChars(env,jemail,cemail);        int ret = nc_loginUser(&cloud_user);        return (jint)ret;    }/* * 登出云 */    JNIEXPORT jint JNICALL Java_com_hdcctv_issmobile_NetApi_CloudUserLogout(JNIEnv *env, jobject obj)    {        int ret = nc_logoutUser();        return (jint)ret;    }/** * 获取云设备列表 */    JNIEXPORT jint JNICALL Java_com_hdcctv_issmobile_NetApi_GetDevicesList(JNIEnv *env, jobject obj,jobject user,jobject devices,jobject device)    {        jclass info_cls = (*env)->GetObjectClass(env,user);//FindClass无法找到，原因未知，直接传入类，暂时解决该问题        jclass devices_cls = (*env)->GetObjectClass(env,devices);        jclass device_cls = (*env)->GetObjectClass(env,device);        if(devices_cls == NULL || info_cls == NULL || device_cls == NULL)        {            LOGI("GetObjectClasseee");            return -99;        }        jmethodID list_add = (*env)->GetMethodID(env,devices_cls,"add","(Ljava/lang/Object;)Z");        jmethodID device_init = (*env)->GetMethodID(env,device_cls,"<init>","(Ljava/lang/String;Ljava/lang/String;)V");        jfieldID user_FiledId = (*env)->GetFieldID(env,info_cls,"username","Ljava/lang/String;");        jfieldID pswd_FiledId = (*env)->GetFieldID(env,info_cls,"password","Ljava/lang/String;");        jfieldID mobile_FiledId = (*env)->GetFieldID(env,info_cls,"mobile","Ljava/lang/String;");        jfieldID email_FiledId = (*env)->GetFieldID(env,info_cls,"email","Ljava/lang/String;");        jfieldID local_FiledId = (*env)->GetFieldID(env,info_cls,"location","I");        if(user_FiledId == NULL || pswd_FiledId == NULL           || mobile_FiledId == NULL || email_FiledId == NULL || local_FiledId == NULL)        {            return -99;        }        jint jlocation = (jint)(*env)->GetIntField(env,user ,local_FiledId);        jstring jusername = (jstring)(*env)->GetObjectField(env,user ,user_FiledId);        jstring jpassword = (jstring)(*env)->GetObjectField(env,user ,pswd_FiledId);        jstring jmobile = (jstring)(*env)->GetObjectField(env,user ,mobile_FiledId);        jstring jemail = (jstring)(*env)->GetObjectField(env,user ,email_FiledId);        const char* cusername = (*env)->GetStringUTFChars(env,jusername, NULL);        const char* cpassword = (*env)->GetStringUTFChars(env,jpassword, NULL);        const char* cmobile = (*env)->GetStringUTFChars(env,jmobile, NULL);        const char* cemail = (*env)->GetStringUTFChars(env,jemail, NULL);        hdcctv_cloud_user_t cloud_user;        memset(&cloud_user,0,sizeof(hdcctv_cloud_user_t));        memcpy(cloud_user.username,cusername,sizeof(cloud_user.username));        memcpy(cloud_user.password,cpassword,sizeof(cloud_user.password));        memcpy(cloud_user.mobile,cmobile,sizeof(cloud_user.mobile));        memcpy(cloud_user.email,cemail,sizeof(cloud_user.email));        if((int)jlocation == 1)            cloud_user.location = HDCCTV_LOCATION_CN;        else            cloud_user.location = HDCCTV_LOCATION_US;        (*env)->ReleaseStringUTFChars(env,jusername,cusername);        (*env)->ReleaseStringUTFChars(env,jpassword,cpassword);        (*env)->ReleaseStringUTFChars(env,jmobile,cmobile);        (*env)->ReleaseStringUTFChars(env,jemail,cemail);        hdcctv_device_list_t pst_device_list;        memset(&pst_device_list,0,sizeof(hdcctv_device_list_t));        int ret = nc_getDevList(&cloud_user, &pst_device_list);        if(ret<0)            return (jint)ret;        else        {            int i = 0;            for(i=0;i<pst_device_list.num;i++)            {                hdcctv_device_t pst_device= pst_device_list.device[i];                jstring devid = (*env)->NewStringUTF(env,pst_device.dev_id);                jstring dev_name = (*env)->NewStringUTF(env,pst_device.dev_name);                jobject deviceobj = (*env)->NewObject(env,device_cls,device_init,dev_name,devid);                (*env)->CallBooleanMethod(env,devices,list_add,deviceobj);                (*env)->DeleteLocalRef (env, devid);                (*env)->DeleteLocalRef (env, dev_name);            }        }        return (jint)ret;    }/* * 添加云设备 */    JNIEXPORT jint JNICALL Java_com_hdcctv_issmobile_NetApi_AddCloudDevice(JNIEnv *env, jobject obj,jobject user,jobject device)    {        jclass info_cls = (*env)->GetObjectClass(env,user);//FindClass无法找到，原因未知，直接传入类，暂时解决该问题        jclass device_cls = (*env)->GetObjectClass(env,device);        if( info_cls == NULL || device_cls == NULL)        {            LOGI("GetObjectClasseee");            return -99;        }        jmethodID device_init = (*env)->GetMethodID(env,device_cls,"<init>","(Ljava/lang/String;Ljava/lang/String;)V");        jfieldID user_FiledId = (*env)->GetFieldID(env,info_cls,"username","Ljava/lang/String;");        jfieldID pswd_FiledId = (*env)->GetFieldID(env,info_cls,"password","Ljava/lang/String;");        jfieldID mobile_FiledId = (*env)->GetFieldID(env,info_cls,"mobile","Ljava/lang/String;");        jfieldID email_FiledId = (*env)->GetFieldID(env,info_cls,"email","Ljava/lang/String;");        jfieldID local_FiledId = (*env)->GetFieldID(env,info_cls,"location","I");        jfieldID device_name_FiledId = (*env)->GetFieldID(env,device_cls,"device_name","Ljava/lang/String;");        jfieldID device_id_FiledId = (*env)->GetFieldID(env,device_cls,"id","Ljava/lang/String;");        if(user_FiledId == NULL || pswd_FiledId == NULL           || mobile_FiledId == NULL || email_FiledId == NULL || local_FiledId == NULL || device_name_FiledId == NULL || device_id_FiledId == NULL)        {            return -99;        }        jint jlocation = (jint)(*env)->GetIntField(env,user ,local_FiledId);        jstring jusername = (jstring)(*env)->GetObjectField(env,user ,user_FiledId);        jstring jpassword = (jstring)(*env)->GetObjectField(env,user ,pswd_FiledId);        jstring jmobile = (jstring)(*env)->GetObjectField(env,user ,mobile_FiledId);        jstring jemail = (jstring)(*env)->GetObjectField(env,user ,email_FiledId);        jstring jdeviceuser = (jstring)(*env)->GetObjectField(env,device ,device_name_FiledId);        jstring jdeviceid = (jstring)(*env)->GetObjectField(env,device ,device_id_FiledId);        const char* cusername = (*env)->GetStringUTFChars(env,jusername, NULL);        const char* cpassword = (*env)->GetStringUTFChars(env,jpassword, NULL);        const char* cmobile = (*env)->GetStringUTFChars(env,jmobile, NULL);        const char* cemail = (*env)->GetStringUTFChars(env,jemail, NULL);        const char* cdeviceuser = (*env)->GetStringUTFChars(env,jdeviceuser, NULL);        const char* cdeviceid = (*env)->GetStringUTFChars(env,jdeviceid, NULL);        hdcctv_cloud_user_t cloud_user;        memset(&cloud_user,0,sizeof(hdcctv_cloud_user_t));        memcpy(cloud_user.username,cusername,sizeof(cloud_user.username));        memcpy(cloud_user.password,cpassword,sizeof(cloud_user.password));        memcpy(cloud_user.mobile,cmobile,sizeof(cloud_user.mobile));        memcpy(cloud_user.email,cemail,sizeof(cloud_user.email));        if((int)jlocation == 1)            cloud_user.location = HDCCTV_LOCATION_CN;        else            cloud_user.location = HDCCTV_LOCATION_US;        hdcctv_device_t pst_device;        memset(&pst_device,0,sizeof(hdcctv_device_t));        memcpy(pst_device.dev_id,cdeviceid,sizeof(pst_device.dev_id));        memcpy(pst_device.dev_name,cdeviceuser,sizeof(pst_device.dev_name));        //LOGE("nnn %s",pst_device.dev_name);        (*env)->ReleaseStringUTFChars(env,jusername,cusername);        (*env)->ReleaseStringUTFChars(env,jpassword,cpassword);        (*env)->ReleaseStringUTFChars(env,jmobile,cmobile);        (*env)->ReleaseStringUTFChars(env,jemail,cemail);        (*env)->ReleaseStringUTFChars(env,jdeviceuser,cdeviceuser);        (*env)->ReleaseStringUTFChars(env,jdeviceid,cdeviceid);        int ret = nc_addDev(&cloud_user, &pst_device);        return (jint)ret;    }/* * 删除云设备 */    JNIEXPORT jint JNICALL Java_com_hdcctv_issmobile_NetApi_DelCloudDevice(JNIEnv *env, jobject obj,jobject user,jobject device)    {        jclass info_cls = (*env)->GetObjectClass(env,user);//FindClass无法找到，原因未知，直接传入类，暂时解决该问题        jclass device_cls = (*env)->GetObjectClass(env,device);        if(info_cls == NULL || device_cls == NULL)        {            LOGI("GetObjectClasseee");            return -99;        }        jmethodID device_init = (*env)->GetMethodID(env,device_cls,"<init>","(Ljava/lang/String;Ljava/lang/String;)V");        jfieldID user_FiledId = (*env)->GetFieldID(env,info_cls,"username","Ljava/lang/String;");        jfieldID pswd_FiledId = (*env)->GetFieldID(env,info_cls,"password","Ljava/lang/String;");        jfieldID mobile_FiledId = (*env)->GetFieldID(env,info_cls,"mobile","Ljava/lang/String;");        jfieldID email_FiledId = (*env)->GetFieldID(env,info_cls,"email","Ljava/lang/String;");        jfieldID local_FiledId = (*env)->GetFieldID(env,info_cls,"location","I");        jfieldID device_name_FiledId = (*env)->GetFieldID(env,device_cls,"device_name","Ljava/lang/String;");        jfieldID device_id_FiledId = (*env)->GetFieldID(env,device_cls,"id","Ljava/lang/String;");        if(user_FiledId == NULL || pswd_FiledId == NULL           || mobile_FiledId == NULL || email_FiledId == NULL || local_FiledId == NULL || device_name_FiledId == NULL || device_id_FiledId == NULL)        {            return -99;        }        jint jlocation = (jint)(*env)->GetIntField(env,user ,local_FiledId);        jstring jusername = (jstring)(*env)->GetObjectField(env,user ,user_FiledId);        jstring jpassword = (jstring)(*env)->GetObjectField(env,user ,pswd_FiledId);        jstring jmobile = (jstring)(*env)->GetObjectField(env,user ,mobile_FiledId);        jstring jemail = (jstring)(*env)->GetObjectField(env,user ,email_FiledId);        jstring jdeviceuser = (jstring)(*env)->GetObjectField(env,device ,device_name_FiledId);        jstring jdeviceid = (jstring)(*env)->GetObjectField(env,device ,device_id_FiledId);        const char* cusername = (*env)->GetStringUTFChars(env,jusername, NULL);        const char* cpassword = (*env)->GetStringUTFChars(env,jpassword, NULL);        const char* cmobile = (*env)->GetStringUTFChars(env,jmobile, NULL);        const char* cemail = (*env)->GetStringUTFChars(env,jemail, NULL);        const char* cdeviceuser = (*env)->GetStringUTFChars(env,jdeviceuser, NULL);        const char* cdeviceid = (*env)->GetStringUTFChars(env,jdeviceid, NULL);        hdcctv_cloud_user_t cloud_user;        memset(&cloud_user,0,sizeof(hdcctv_cloud_user_t));        memcpy(cloud_user.username,cusername,sizeof(cloud_user.username));        memcpy(cloud_user.password,cpassword,sizeof(cloud_user.password));        memcpy(cloud_user.mobile,cmobile,sizeof(cloud_user.mobile));        memcpy(cloud_user.email,cemail,sizeof(cloud_user.email));        if((int)jlocation == 1)            cloud_user.location = HDCCTV_LOCATION_CN;        else            cloud_user.location = HDCCTV_LOCATION_US;        hdcctv_device_t pst_device;        memset(&pst_device,0,sizeof(hdcctv_device_t));        memcpy(pst_device.dev_id,cdeviceid,sizeof(pst_device.dev_id));        memcpy(pst_device.dev_name,cdeviceuser,sizeof(pst_device.dev_name));        (*env)->ReleaseStringUTFChars(env,jusername,cusername);        (*env)->ReleaseStringUTFChars(env,jpassword,cpassword);        (*env)->ReleaseStringUTFChars(env,jmobile,cmobile);        (*env)->ReleaseStringUTFChars(env,jemail,cemail);        (*env)->ReleaseStringUTFChars(env,jdeviceuser,cdeviceuser);        (*env)->ReleaseStringUTFChars(env,jdeviceid,cdeviceid);        int ret = nc_delDev(&cloud_user, &pst_device);        return (jint)ret;    }/** * 获取报警配置 */    JNIEXPORT jint JNICALL Java_com_hdcctv_issmobile_NetApi_GetAlarmCfg(JNIEnv *env, jobject obj,jint devicetype,                                                                        jstring id,jstring ip, jint port, jint sport,jstring username, jstring password,jint type,jobject configarray,jobject config)    {        jboolean iscopy;        const char* str_id = (*env)->GetStringUTFChars(env,id,NULL);        const char* str_ip = (*env)->GetStringUTFChars(env,ip,NULL);        const char* str_user = (*env)->GetStringUTFChars(env,username,NULL);        const char* str_pwd = (*env)->GetStringUTFChars(env,password,NULL);        if((str_ip == NULL) || (str_user == NULL) || (str_pwd == NULL))        {            // (*env)->ReleaseCharArrayElements(env,channel,buf,0);            (*env)->ReleaseStringUTFChars(env,id,str_id);            (*env)->ReleaseStringUTFChars(env,ip,str_ip);            (*env)->ReleaseStringUTFChars(env,username,str_user);            (*env)->ReleaseStringUTFChars(env,password,str_pwd);            return (jint)-1;        }        jclass list_cls = (*env)->GetObjectClass(env,configarray);        if(list_cls == NULL)        {            LOGI("GetObjectClass");            return -99;        }        jmethodID list_add = (*env)->GetMethodID(env,list_cls,"add","(Ljava/lang/Object;)Z");        jclass cfg_cls = (*env)->GetObjectClass(env,config);//FindClass无法找到，原因未知，直接传入类，暂时解决该问题        if(cfg_cls == NULL)        {            LOGI("GetObjectClass++");            return -99;        }        jmethodID cfg_costruct = (*env)->GetMethodID(env,cfg_cls,"<init>","(FFFFI)V");        nc_dev dev;        DeviceInit(&dev,(int)devicetype,str_id,str_ip,(int)port,(int)sport,str_user,str_pwd);        (*env)->ReleaseStringUTFChars(env,id,str_id);        (*env)->ReleaseStringUTFChars(env,ip,str_ip);        (*env)->ReleaseStringUTFChars(env,username,str_user);        (*env)->ReleaseStringUTFChars(env,password,str_pwd);        ptc_cfg_alarm_t alarmCfg;        memset(&alarmCfg,0,sizeof(ptc_cfg_alarm_t));        int ret = nc_getCfg_alarm(&dev, (int)type, &alarmCfg);        if(ret < 0)        {            return ret;        }        /* LOGE("enable = %d ",alarmCfg.enable);         LOGE("right_down (%f %f)",alarmCfg.rect.right_down.x,alarmCfg.rect.right_down.y);         LOGE("right_down (%f %f)",alarmCfg.rect.left_down.x,alarmCfg.rect.left_down.y);         LOGE("right_down (%f %f)",alarmCfg.rect.left_up.x,alarmCfg.rect.right_down.y);         LOGE("right_down (%f %f)",alarmCfg.rect.right_up.x,alarmCfg.rect.right_up.y);*/        if(alarmCfg.enable == 1)        {            if(alarmCfg.rect.right_down.x < 0 || alarmCfg.rect.right_down.x > 100 || alarmCfg.rect.right_down.y < 0 || alarmCfg.rect.right_down.y > 100               || alarmCfg.rect.left_down.x < 0 || alarmCfg.rect.left_down.x > 100 || alarmCfg.rect.left_down.y < 0 || alarmCfg.rect.left_down.y > 100               || alarmCfg.rect.left_up.x < 0 || alarmCfg.rect.left_up.x > 100 || alarmCfg.rect.left_up.y < 0 || alarmCfg.rect.left_up.y > 100               || alarmCfg.rect.right_up.x < 0 || alarmCfg.rect.right_up.x > 100 || alarmCfg.rect.right_up.y < 0 || alarmCfg.rect.right_up.y > 100)                return -1;        }        if(alarmCfg.enable == 1)        {            if((jint)type == PTC_ALARM_TYPE_TA_FOCUS || (jint)type == PTC_ALARM_TYPE_TA_COVER)                return 1;            jobject cfgobj = (*env)->NewObject(env,cfg_cls,cfg_costruct,(jfloat)0,(jfloat)0,(jfloat)alarmCfg.rect.right_down.x,(jfloat)alarmCfg.rect.right_down.y,1);            (*env)->CallBooleanMethod(env,configarray,list_add,cfgobj);            cfgobj = (*env)->NewObject(env,cfg_cls,cfg_costruct,(jfloat)0,(jfloat)0,(jfloat)alarmCfg.rect.left_down.x,(jfloat)alarmCfg.rect.left_down.y,2);            (*env)->CallBooleanMethod(env,configarray,list_add,cfgobj);            if((jint)type == PTC_ALARM_TYPE_VMF_LINE)            {            }            else            {                cfgobj = (*env)->NewObject(env,cfg_cls,cfg_costruct,(jfloat)0,(jfloat)0,(jfloat)alarmCfg.rect.left_up.x,(jfloat)alarmCfg.rect.left_up.y,3);                (*env)->CallBooleanMethod(env,configarray,list_add,cfgobj);                cfgobj = (*env)->NewObject(env,cfg_cls,cfg_costruct,(jfloat)0,(jfloat)0,(jfloat)alarmCfg.rect.right_up.x,(jfloat)alarmCfg.rect.right_up.y,4);                (*env)->CallBooleanMethod(env,configarray,list_add,cfgobj);            }        }        else        {            if((jint)type == PTC_ALARM_TYPE_TA_FOCUS || (jint)type == PTC_ALARM_TYPE_TA_COVER)                return 0;        }        return ret;    }/** * 设置报警 */    JNIEXPORT jint JNICALL Java_com_hdcctv_issmobile_NetApi_SetAlarmCfg(JNIEnv *env, jobject obj,jint devicetype,                                                                        jstring id,jstring ip, jint port, jint sport,jstring username, jstring password,jint type,jint status,jobject configarray)    {        jboolean iscopy;        const char* str_id = (*env)->GetStringUTFChars(env,id,NULL);        const char* str_ip = (*env)->GetStringUTFChars(env,ip,NULL);        const char* str_user = (*env)->GetStringUTFChars(env,username,NULL);        const char* str_pwd = (*env)->GetStringUTFChars(env,password,NULL);        if((str_ip == NULL) || (str_user == NULL) || (str_pwd == NULL))        {            // (*env)->ReleaseCharArrayElements(env,channel,buf,0);            (*env)->ReleaseStringUTFChars(env,id,str_id);            (*env)->ReleaseStringUTFChars(env,ip,str_ip);            (*env)->ReleaseStringUTFChars(env,username,str_user);            (*env)->ReleaseStringUTFChars(env,password,str_pwd);            return (jint)-1;        }        nc_dev dev;        DeviceInit(&dev,(int)devicetype,str_id,str_ip,(int)port,(int)sport,str_user,str_pwd);        (*env)->ReleaseStringUTFChars(env,id,str_id);        (*env)->ReleaseStringUTFChars(env,ip,str_ip);        (*env)->ReleaseStringUTFChars(env,username,str_user);        (*env)->ReleaseStringUTFChars(env,password,str_pwd);        ptc_cfg_alarm_t alarmCfg;        memset(&alarmCfg,0,sizeof(ptc_cfg_alarm_t));        if((jint)type == PTC_ALARM_TYPE_TA_FOCUS || (jint)type == PTC_ALARM_TYPE_TA_COVER)        {            alarmCfg.enable = (jint)status;        }        else        {            jclass list_cls = (*env)->GetObjectClass(env,configarray);            if(list_cls == NULL)            {                LOGI("GetObjectClass");                return -99;            }            jmethodID list_get = (*env)->GetMethodID(env,list_cls,"get","(I)Ljava/lang/Object;");            jmethodID list_size = (*env)->GetMethodID(env,list_cls,"size","()I");            int len =  (*env)->CallIntMethod(env,configarray,list_size);            //LOGE("len = %d",len);            if(len>0)                alarmCfg.enable = 1;            int i=0;            for(i=0;i<len;i++)            {                jobject cfg_obj = (*env)->CallObjectMethod(env,configarray,list_get,i);                jclass cfg_cls = (*env)->GetObjectClass(env,cfg_obj);                jmethodID cfg_getx = (*env)->GetMethodID(env,cfg_cls,"getPercentX","()F");                jmethodID cfg_gety = (*env)->GetMethodID(env,cfg_cls,"getPercentY","()F");                jfloat x = (*env)->CallFloatMethod(env,cfg_obj,cfg_getx);                jfloat y = (*env)->CallFloatMethod(env,cfg_obj,cfg_gety);                if(i == 0)                {                    alarmCfg.rect.right_down.x = x;                    alarmCfg.rect.right_down.y = y;                }                else if(i == 1)                {                    alarmCfg.rect.left_down.x = x;                    alarmCfg.rect.left_down.y = y;                }                else if(i == 2)                {                    alarmCfg.rect.left_up.x = x;                    alarmCfg.rect.left_up.y = y;                }                else if(i == 3)                {                    alarmCfg.rect.right_up.x = x;                    alarmCfg.rect.right_up.y = y;                }            }            if(alarmCfg.enable == 1)            {                if(alarmCfg.rect.right_down.x < 0 || alarmCfg.rect.right_down.x > 100 || alarmCfg.rect.right_down.y < 0 || alarmCfg.rect.right_down.y > 100                   || alarmCfg.rect.left_down.x < 0 || alarmCfg.rect.left_down.x > 100 || alarmCfg.rect.left_down.y < 0 || alarmCfg.rect.left_down.y > 100                   || alarmCfg.rect.left_up.x < 0 || alarmCfg.rect.left_up.x > 100 || alarmCfg.rect.left_up.y < 0 || alarmCfg.rect.left_up.y > 100                   || alarmCfg.rect.right_up.x < 0 || alarmCfg.rect.right_up.x > 100 || alarmCfg.rect.right_up.y < 0 || alarmCfg.rect.right_up.y > 100)                    return 0;            }        }        int ret = nc_setCfg_alarm(&dev, (int)type, &alarmCfg);/*    LOGE("enable = %d ",alarmCfg.enable);    LOGE("right_down (%f %f)",alarmCfg.rect.right_down.x,alarmCfg.rect.right_down.y);    LOGE("right_down (%f %f)",alarmCfg.rect.left_down.x,alarmCfg.rect.left_down.y);    LOGE("right_down (%f %f)",alarmCfg.rect.left_up.x,alarmCfg.rect.left_up.y);    LOGE("right_down (%f %f)",alarmCfg.rect.right_up.x,alarmCfg.rect.right_up.y);*/        return ret;    }/** * 设置3G拨号 */    JNIEXPORT jint JNICALL Java_com_hdcctv_issmobile_NetApi_SetMobileCfg(JNIEnv *env, jobject obj,jint devicetype,                                                                         jstring id,jstring ip, jint port, jint sport,jstring username, jstring password,jobject config)    {        jboolean iscopy;        const char* str_id = (*env)->GetStringUTFChars(env,id,NULL);        const char* str_ip = (*env)->GetStringUTFChars(env,ip,NULL);        const char* str_user = (*env)->GetStringUTFChars(env,username,NULL);        const char* str_pwd = (*env)->GetStringUTFChars(env,password,NULL);        if((str_ip == NULL) || (str_user == NULL) || (str_pwd == NULL))        {            // (*env)->ReleaseCharArrayElements(env,channel,buf,0);            (*env)->ReleaseStringUTFChars(env,id,str_id);            (*env)->ReleaseStringUTFChars(env,ip,str_ip);            (*env)->ReleaseStringUTFChars(env,username,str_user);            (*env)->ReleaseStringUTFChars(env,password,str_pwd);            return (jint)-1;        }        nc_dev dev;        DeviceInit(&dev,(int)devicetype,str_id,str_ip,(int)port,(int)sport,str_user,str_pwd);        (*env)->ReleaseStringUTFChars(env,id,str_id);        (*env)->ReleaseStringUTFChars(env,ip,str_ip);        (*env)->ReleaseStringUTFChars(env,username,str_user);        (*env)->ReleaseStringUTFChars(env,password,str_pwd);        jclass info_cls = (*env)->GetObjectClass(env,config);//FindClass无法找到，原因未知，直接传入类，暂时解决该问题        if(info_cls == NULL)        {            LOGI("GetObjectClasseee");            return -99;        }        jmethodID cfg_getenable = (*env)->GetMethodID(env,info_cls,"getEnable","()I");        jint enable = (*env)->CallIntMethod(env,config,cfg_getenable);        LOGE("enable == %d",enable);        ptc_cfg_mobile_t mobile;        memset(&mobile,0,sizeof(ptc_cfg_mobile_t));        mobile.enable_3g = enable;        int ret = nc_setCfg_mobile(&dev, &mobile);        return (jint)ret;    }/** * 查询3G拨号状态 */    JNIEXPORT jint JNICALL Java_com_hdcctv_issmobile_NetApi_GetMobileCfg(JNIEnv *env, jobject obj,jint devicetype,                                                                         jstring id,jstring ip, jint port, jint sport,jstring username, jstring password,jobject config)    {        jboolean iscopy;        const char* str_id = (*env)->GetStringUTFChars(env,id,NULL);        const char* str_ip = (*env)->GetStringUTFChars(env,ip,NULL);        const char* str_user = (*env)->GetStringUTFChars(env,username,NULL);        const char* str_pwd = (*env)->GetStringUTFChars(env,password,NULL);        if((str_ip == NULL) || (str_user == NULL) || (str_pwd == NULL))        {            // (*env)->ReleaseCharArrayElements(env,channel,buf,0);            (*env)->ReleaseStringUTFChars(env,id,str_id);            (*env)->ReleaseStringUTFChars(env,ip,str_ip);            (*env)->ReleaseStringUTFChars(env,username,str_user);            (*env)->ReleaseStringUTFChars(env,password,str_pwd);            return (jint)-1;        }        nc_dev dev;        DeviceInit(&dev,(int)devicetype,str_id,str_ip,(int)port,(int)sport,str_user,str_pwd);        (*env)->ReleaseStringUTFChars(env,id,str_id);        (*env)->ReleaseStringUTFChars(env,ip,str_ip);        (*env)->ReleaseStringUTFChars(env,username,str_user);        (*env)->ReleaseStringUTFChars(env,password,str_pwd);        ptc_cfg_mobile_t mobile;        memset(&mobile,0,sizeof(ptc_cfg_mobile_t));        int ret=nc_getCfg_mobile(&dev, &mobile);        if(ret<0)            return (jint)ret;        jclass info_cls = (*env)->GetObjectClass(env,config);//FindClass无法找到，原因未知，直接传入类，暂时解决该问题        if(info_cls == NULL)        {            LOGI("GetObjectClasseee");            return -99;        }        //获得该类型的构造函数   返回类型必须为 void 即 V 如果有混淆代码需要保持该名称不改变        jmethodID info_set = (*env)->GetMethodID(env,info_cls,"setMobileInfo","(II)V");        (*env)->CallVoidMethod(env,config,info_set,(jint)mobile.enable_3g,(jint)mobile.status_3g);        LOGE("enable == %d status = %d",mobile.enable_3g,mobile.status_3g);        return ret;    }/** * 设置wifi */    JNIEXPORT jint JNICALL Java_com_hdcctv_issmobile_NetApi_SetWiFiCfg(JNIEnv *env, jobject obj,jint devicetype,                                                                       jstring id,jstring ip, jint port, jint sport,jstring username, jstring password,jobject config)    {        jboolean iscopy;        const char* str_id = (*env)->GetStringUTFChars(env,id,NULL);        const char* str_ip = (*env)->GetStringUTFChars(env,ip,NULL);        const char* str_user = (*env)->GetStringUTFChars(env,username,NULL);        const char* str_pwd = (*env)->GetStringUTFChars(env,password,NULL);        if((str_ip == NULL) || (str_user == NULL) || (str_pwd == NULL))        {            // (*env)->ReleaseCharArrayElements(env,channel,buf,0);            (*env)->ReleaseStringUTFChars(env,id,str_id);            (*env)->ReleaseStringUTFChars(env,ip,str_ip);            (*env)->ReleaseStringUTFChars(env,username,str_user);            (*env)->ReleaseStringUTFChars(env,password,str_pwd);            return (jint)-1;        }        nc_dev dev;        DeviceInit(&dev,(int)devicetype,str_id,str_ip,(int)port,(int)sport,str_user,str_pwd);        (*env)->ReleaseStringUTFChars(env,id,str_id);        (*env)->ReleaseStringUTFChars(env,ip,str_ip);        (*env)->ReleaseStringUTFChars(env,username,str_user);        (*env)->ReleaseStringUTFChars(env,password,str_pwd);        jclass info_cls = (*env)->GetObjectClass(env,config);//FindClass无法找到，原因未知，直接传入类，暂时解决该问题        if(info_cls == NULL)        {            LOGI("GetObjectClasseee");            return -99;        }        jfieldID mode_FiledId = (*env)->GetFieldID(env,info_cls,"mode","I");        jfieldID client_ssid_FiledId = (*env)->GetFieldID(env,info_cls,"client_ssid","Ljava/lang/String;");        jfieldID client_pswd_FiledId = (*env)->GetFieldID(env,info_cls,"client_pswd","Ljava/lang/String;");        jfieldID client_level_FiledId = (*env)->GetFieldID(env,info_cls,"client_level","I");        jfieldID client_dhcp_FiledId = (*env)->GetFieldID(env,info_cls,"client_dhcp","I");        jfieldID client_ip_FiledId = (*env)->GetFieldID(env,info_cls,"client_ip","Ljava/lang/String;");        jfieldID client_mask_FiledId = (*env)->GetFieldID(env,info_cls,"client_mask","Ljava/lang/String;");        jfieldID client_gate_FiledId = (*env)->GetFieldID(env,info_cls,"client_gate","Ljava/lang/String;");        jfieldID client_dns1_FiledId = (*env)->GetFieldID(env,info_cls,"client_dns1","Ljava/lang/String;");        jfieldID client_dns2_FiledId = (*env)->GetFieldID(env,info_cls,"client_dns2","Ljava/lang/String;");        jfieldID ap_ssid_FiledId = (*env)->GetFieldID(env,info_cls,"ap_ssid","Ljava/lang/String;");        jfieldID ap_pswd_FiledId = (*env)->GetFieldID(env,info_cls,"ap_pswd","Ljava/lang/String;");        if(client_ssid_FiledId == NULL || client_pswd_FiledId == NULL           || client_ip_FiledId == NULL || client_mask_FiledId == NULL || client_gate_FiledId == NULL || client_dns1_FiledId == NULL || client_dns2_FiledId == NULL           || ap_ssid_FiledId == NULL || ap_pswd_FiledId == NULL)        {            return -99;        }        jint mode = (jint)(*env)->GetIntField(env,config ,mode_FiledId);        jstring jclient_ssid = (jstring)(*env)->GetObjectField(env,config ,client_ssid_FiledId);        jstring jclient_pswd = (jstring)(*env)->GetObjectField(env,config ,client_pswd_FiledId);        jint client_level = (jint)(*env)->GetIntField(env,config ,client_level_FiledId);        jint client_dhcp = (jint)(*env)->GetIntField(env,config ,client_dhcp_FiledId);        jstring jclient_ip = (jstring)(*env)->GetObjectField(env,config ,client_ip_FiledId);        jstring jclient_mask = (jstring)(*env)->GetObjectField(env,config ,client_mask_FiledId);        jstring jclient_gate = (jstring)(*env)->GetObjectField(env,config ,client_gate_FiledId);        jstring jclient_dns1 = (jstring)(*env)->GetObjectField(env,config ,client_dns1_FiledId);        jstring jclient_dns2 = (jstring)(*env)->GetObjectField(env,config ,client_dns2_FiledId);        jstring jap_ssid = (jstring)(*env)->GetObjectField(env,config ,ap_ssid_FiledId);        jstring jap_pswd = (jstring)(*env)->GetObjectField(env,config ,ap_pswd_FiledId);        const char* cclient_ssid = (*env)->GetStringUTFChars(env,jclient_ssid, NULL);        const char* cclient_pswd = (*env)->GetStringUTFChars(env,jclient_pswd, NULL);        const char* cclient_ip = (*env)->GetStringUTFChars(env,jclient_ip, NULL);        const char* cclient_mask = (*env)->GetStringUTFChars(env,jclient_mask, NULL);        const char* cclient_gate = (*env)->GetStringUTFChars(env,jclient_gate, NULL);        const char* cclient_dns1 = (*env)->GetStringUTFChars(env,jclient_dns1, NULL);        const char* cclient_dns2 = (*env)->GetStringUTFChars(env,jclient_dns2, NULL);        const char* cap_ssid = (*env)->GetStringUTFChars(env,jap_ssid, NULL);        const char* cap_pswd = (*env)->GetStringUTFChars(env,jap_pswd, NULL);        ptc_cfg_wifi_t wifi;        memset(&wifi,0,sizeof(ptc_cfg_wifi_t));        wifi.mode = mode;        LOGE("mode %d",mode);        memcpy(wifi.client_ssid,cclient_ssid,sizeof(wifi.client_ssid));        LOGE("cclient_ssid %s",cclient_ssid);        memcpy(wifi.client_pswd,cclient_pswd,sizeof(wifi.client_pswd));        LOGE("cclient_pswd %s",cclient_pswd);        wifi.client_level = client_level;        wifi.client_dhcp = client_dhcp;        LOGE("level %d",client_level);        LOGE("client_dhcp %d",client_dhcp);        sscanf(cclient_ip,"%d.%d.%d.%d",&wifi.client_ip[0],&wifi.client_ip[1],&wifi.client_ip[2],&wifi.client_ip[3]);        LOGE("cclient_ip %d %d %d %d",wifi.client_ip[0],wifi.client_ip[1],wifi.client_ip[2],wifi.client_ip[3]);        sscanf(cclient_mask,"%d.%d.%d.%d",&wifi.client_mask[0],&wifi.client_mask[1],&wifi.client_mask[2],&wifi.client_mask[3]);        LOGE("cclient_mask %d %d %d %d",wifi.client_mask[0],wifi.client_mask[1],wifi.client_mask[2],wifi.client_mask[3]);        sscanf(cclient_gate,"%d.%d.%d.%d",&wifi.client_gate[0],&wifi.client_gate[1],&wifi.client_gate[2],&wifi.client_gate[3]);        LOGE("cclient_gate %d %d %d %d",wifi.client_gate[0],wifi.client_gate[1],wifi.client_gate[2],wifi.client_gate[3]);        sscanf(cclient_dns1,"%d.%d.%d.%d",&wifi.client_dns1[0],&wifi.client_dns1[1],&wifi.client_dns1[2],&wifi.client_dns1[3]);        LOGE("cclient_dns1 %d %d %d %d",wifi.client_dns1[0],wifi.client_dns1[1],wifi.client_dns1[2],wifi.client_dns1[3]);        sscanf(cclient_dns2,"%d.%d.%d.%d",&wifi.client_dns2[0],&wifi.client_dns2[1],&wifi.client_dns2[2],&wifi.client_dns2[3]);        LOGE("cclient_dns2 %d %d %d %d",wifi.client_dns2[0],wifi.client_dns2[1],wifi.client_dns2[2],wifi.client_dns2[3]);        memcpy(wifi.ap_ssid,cap_ssid,sizeof(wifi.ap_ssid));        LOGE("ap_ssid %s",cap_ssid);        memcpy(wifi.ap_pswd,cap_pswd,sizeof(wifi.ap_pswd));        LOGE("cap_pswd %s",cap_pswd);        (*env)->ReleaseStringUTFChars(env,jclient_ssid,cclient_ssid);        (*env)->ReleaseStringUTFChars(env,jclient_pswd,cclient_pswd);        (*env)->ReleaseStringUTFChars(env,jclient_ip,cclient_ip);        (*env)->ReleaseStringUTFChars(env,jclient_mask,cclient_mask);        (*env)->ReleaseStringUTFChars(env,jclient_gate,cclient_gate);        (*env)->ReleaseStringUTFChars(env,jclient_dns1,cclient_dns1);        (*env)->ReleaseStringUTFChars(env,jclient_dns2,cclient_dns2);        (*env)->ReleaseStringUTFChars(env,jap_ssid,cap_ssid);        (*env)->ReleaseStringUTFChars(env,jap_ssid,cap_pswd);        int ret=nc_setCfg_wifi(&dev, &wifi);        return (jint)ret;    }/** * 查询wifi */    JNIEXPORT jint JNICALL Java_com_hdcctv_issmobile_NetApi_GetWiFiCfg(JNIEnv *env, jobject obj,jint devicetype,                                                                       jstring id,jstring ip, jint port, jint sport,jstring username, jstring password,jobject config)    {        jboolean iscopy;        const char* str_id = (*env)->GetStringUTFChars(env,id,NULL);        const char* str_ip = (*env)->GetStringUTFChars(env,ip,NULL);        const char* str_user = (*env)->GetStringUTFChars(env,username,NULL);        const char* str_pwd = (*env)->GetStringUTFChars(env,password,NULL);        if((str_ip == NULL) || (str_user == NULL) || (str_pwd == NULL))        {            // (*env)->ReleaseCharArrayElements(env,channel,buf,0);            (*env)->ReleaseStringUTFChars(env,id,str_id);            (*env)->ReleaseStringUTFChars(env,ip,str_ip);            (*env)->ReleaseStringUTFChars(env,username,str_user);            (*env)->ReleaseStringUTFChars(env,password,str_pwd);            return (jint)-1;        }        nc_dev dev;        DeviceInit(&dev,(int)devicetype,str_id,str_ip,(int)port,(int)sport,str_user,str_pwd);        (*env)->ReleaseStringUTFChars(env,id,str_id);        (*env)->ReleaseStringUTFChars(env,ip,str_ip);        (*env)->ReleaseStringUTFChars(env,username,str_user);        (*env)->ReleaseStringUTFChars(env,password,str_pwd);        ptc_cfg_wifi_t wifi;        memset(&wifi,0,sizeof(ptc_cfg_wifi_t));        int ret=nc_getCfg_wifi(&dev, &wifi);        /* LOGE("cclient_ip %d %d %d %d",wifi.client_ip[0],wifi.client_ip[1],wifi.client_ip[2],wifi.client_ip[3]);         LOGE("cclient_mask %d %d %d %d",wifi.client_mask[0],wifi.client_mask[1],wifi.client_mask[2],wifi.client_mask[3]);         LOGE("cclient_gate %d %d %d %d",wifi.client_gate[0],wifi.client_gate[1],wifi.client_gate[2],wifi.client_gate[3]);         LOGE("cclient_dns1 %d %d %d %d",wifi.client_dns1[0],wifi.client_dns1[1],wifi.client_dns1[2],wifi.client_dns1[3]);         LOGE("cclient_dns2 %d %d %d %d",wifi.client_dns2[0],wifi.client_dns2[1],wifi.client_dns2[2],wifi.client_dns2[3]);*/        if(ret<0)            return (jint)ret;        jclass wifi_cls = (*env)->GetObjectClass(env,config);//FindClass无法找到，原因未知，直接传入类，暂时解决该问题        if(wifi_cls == NULL)        {            LOGI("GetObjectClasseee");            return -99;        }        //获得该类型的构造函数   返回类型必须为 void 即 V 如果有混淆代码需要保持该名称不改变        jmethodID wifi_set = (*env)->GetMethodID(env,wifi_cls,"setWiFiInfo","(ILjava/lang/String;Ljava/lang/String;IILjava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)V");        char client_ip[64];        char client_mask[64];        char client_gate[64];        char client_dns1[64];        char client_dns2[64];        memset(client_ip,0,64);        memset(client_mask,0,64);        memset(client_gate,0,64);        memset(client_dns1,0,64);        memset(client_dns2,0,64);        snprintf(client_ip,64,"%d.%d.%d.%d",wifi.client_ip[0],wifi.client_ip[1],wifi.client_ip[2],wifi.client_ip[3]);        snprintf(client_mask,64,"%d.%d.%d.%d",wifi.client_mask[0],wifi.client_mask[1],wifi.client_mask[2],wifi.client_mask[3]);        snprintf(client_gate,64,"%d.%d.%d.%d",wifi.client_gate[0],wifi.client_gate[1],wifi.client_gate[2],wifi.client_gate[3]);        snprintf(client_dns1,64,"%d.%d.%d.%d",wifi.client_dns1[0],wifi.client_dns1[1],wifi.client_dns1[2],wifi.client_dns1[3]);        snprintf(client_dns2,64,"%d.%d.%d.%d",wifi.client_dns2[0],wifi.client_dns2[1],wifi.client_dns2[2],wifi.client_dns2[3]);        jstring str_client_ssid = (*env)->NewStringUTF(env,wifi.client_ssid);        jstring str_client_pswd = (*env)->NewStringUTF(env,wifi.client_pswd);        jstring str_client_ip = (*env)->NewStringUTF(env,client_ip);        jstring str_client_mask = (*env)->NewStringUTF(env,client_mask);        jstring str_client_gate = (*env)->NewStringUTF(env,client_gate);        jstring str_client_dns1 = (*env)->NewStringUTF(env,client_dns1);        jstring str_client_dns2 = (*env)->NewStringUTF(env,client_dns2);        jstring str_ap_ssid = (*env)->NewStringUTF(env,wifi.ap_ssid);        jstring str_ap_pswd = (*env)->NewStringUTF(env,wifi.ap_pswd);//LOGE("ssid =%s  pswd = %s\n",wifi.ap_ssid,wifi.ap_pswd);        (*env)->CallVoidMethod(env,config,wifi_set,(jint)wifi.mode,str_client_ssid,str_client_pswd,(jint)wifi.client_level,(jint)wifi.client_dhcp,str_client_ip,                               str_client_mask,str_client_gate,str_client_dns1,str_client_dns2,str_ap_ssid,str_ap_pswd);        (*env)->DeleteLocalRef (env, str_client_ssid);        (*env)->DeleteLocalRef (env, str_client_pswd);        (*env)->DeleteLocalRef (env, str_client_ip);        (*env)->DeleteLocalRef (env, str_client_mask);        (*env)->DeleteLocalRef (env, str_client_gate);        (*env)->DeleteLocalRef (env, str_client_dns1);        (*env)->DeleteLocalRef (env, str_client_dns2);        (*env)->DeleteLocalRef (env, str_ap_ssid);        (*env)->DeleteLocalRef (env, str_ap_pswd);        return ret;    }/** * 设置存储参数 */    JNIEXPORT jint JNICALL Java_com_hdcctv_issmobile_NetApi_SetStoreCfg(JNIEnv *env, jobject obj,jint devicetype,                                                                        jstring id,jstring ip, jint port, jint sport,jstring username, jstring password,jobject config)    {        jboolean iscopy;        const char* str_id = (*env)->GetStringUTFChars(env,id,NULL);        const char* str_ip = (*env)->GetStringUTFChars(env,ip,NULL);        const char* str_user = (*env)->GetStringUTFChars(env,username,NULL);        const char* str_pwd = (*env)->GetStringUTFChars(env,password,NULL);        if((str_ip == NULL) || (str_user == NULL) || (str_pwd == NULL))        {            // (*env)->ReleaseCharArrayElements(env,channel,buf,0);            (*env)->ReleaseStringUTFChars(env,id,str_id);            (*env)->ReleaseStringUTFChars(env,ip,str_ip);            (*env)->ReleaseStringUTFChars(env,username,str_user);            (*env)->ReleaseStringUTFChars(env,password,str_pwd);            return (jint)-1;        }        nc_dev dev;        DeviceInit(&dev,(int)devicetype,str_id,str_ip,(int)port,(int)sport,str_user,str_pwd);        (*env)->ReleaseStringUTFChars(env,id,str_id);        (*env)->ReleaseStringUTFChars(env,ip,str_ip);        (*env)->ReleaseStringUTFChars(env,username,str_user);        (*env)->ReleaseStringUTFChars(env,password,str_pwd);        jclass info_cls = (*env)->GetObjectClass(env,config);//FindClass无法找到，原因未知，直接传入类，暂时解决该问题        if(info_cls == NULL)        {            LOGI("GetObjectClasseee");            return -99;        }        jfieldID enable_FiledId = (*env)->GetFieldID(env,info_cls,"enable","I");        jfieldID type_FiledId = (*env)->GetFieldID(env,info_cls,"cover_type","I");        jfieldID state_FiledId = (*env)->GetFieldID(env,info_cls,"state","I");        jfieldID total_FiledId = (*env)->GetFieldID(env,info_cls,"total_size","I");        jfieldID left_FiledId = (*env)->GetFieldID(env,info_cls,"left_size","I");        jint enable = (jint)(*env)->GetIntField(env,config ,enable_FiledId);        jint type = (jint)(*env)->GetIntField(env,config ,type_FiledId);        jint state = (jint)(*env)->GetIntField(env,config ,state_FiledId);        jint total = (jint)(*env)->GetIntField(env,config ,total_FiledId);        jint left = (jint)(*env)->GetIntField(env,config ,left_FiledId);        ptc_cfg_devRecord_t devRecord;        memset(&devRecord,0,sizeof(ptc_cfg_devRecord_t));        devRecord.enable = enable;        devRecord.cover_type = type;        devRecord.state = state;        devRecord.total_size = total;        devRecord.left_size = left;        int ret=nc_setCfg_devRecord(&dev, &devRecord);        return (jint)ret;    }/** * 查询存储参数 */    JNIEXPORT jint JNICALL Java_com_hdcctv_issmobile_NetApi_GetStoreCfg(JNIEnv *env, jobject obj,jint devicetype,                                                                        jstring id,jstring ip, jint port, jint sport,jstring username, jstring password,jobject config)    {        jboolean iscopy;        const char* str_id = (*env)->GetStringUTFChars(env,id,NULL);        const char* str_ip = (*env)->GetStringUTFChars(env,ip,NULL);        const char* str_user = (*env)->GetStringUTFChars(env,username,NULL);        const char* str_pwd = (*env)->GetStringUTFChars(env,password,NULL);        if((str_ip == NULL) || (str_user == NULL) || (str_pwd == NULL))        {            // (*env)->ReleaseCharArrayElements(env,channel,buf,0);            (*env)->ReleaseStringUTFChars(env,id,str_id);            (*env)->ReleaseStringUTFChars(env,ip,str_ip);            (*env)->ReleaseStringUTFChars(env,username,str_user);            (*env)->ReleaseStringUTFChars(env,password,str_pwd);            return (jint)-1;        }        nc_dev dev;        DeviceInit(&dev,(int)devicetype,str_id,str_ip,(int)port,(int)sport,str_user,str_pwd);        (*env)->ReleaseStringUTFChars(env,id,str_id);        (*env)->ReleaseStringUTFChars(env,ip,str_ip);        (*env)->ReleaseStringUTFChars(env,username,str_user);        (*env)->ReleaseStringUTFChars(env,password,str_pwd);        ptc_cfg_devRecord_t devRecord;        memset(&devRecord,0,sizeof(ptc_cfg_devRecord_t));        int ret=nc_getCfg_devRecord(&dev, &devRecord);        if(ret<0)            return (jint)ret;        jclass store_cls = (*env)->GetObjectClass(env,config);//FindClass无法找到，原因未知，直接传入类，暂时解决该问题        if(store_cls == NULL)        {            LOGI("GetObjectClasseee");            return -99;        }        //获得该类型的构造函数   返回类型必须为 void 即 V 如果有混淆代码需要保持该名称不改变        jmethodID store_set = (*env)->GetMethodID(env,store_cls,"setRemoteStoreInfo","(IIIII)V");        (*env)->CallVoidMethod(env,config,store_set,(jint)devRecord.enable,(jint)devRecord.cover_type,(jint)devRecord.state,(jint)devRecord.total_size,(jint)devRecord.left_size);        return ret;    }/** * 查询视频参数 */    JNIEXPORT jint JNICALL Java_com_hdcctv_issmobile_NetApi_GetVideoCfg(JNIEnv *env, jobject obj,jint devicetype,                                                                        jstring id,jstring ip, jint port, jint sport,jstring username, jstring password,jobject config)    {        jboolean iscopy;        const char* str_id = (*env)->GetStringUTFChars(env,id,NULL);        const char* str_ip = (*env)->GetStringUTFChars(env,ip,NULL);        const char* str_user = (*env)->GetStringUTFChars(env,username,NULL);        const char* str_pwd = (*env)->GetStringUTFChars(env,password,NULL);        if((str_ip == NULL) || (str_user == NULL) || (str_pwd == NULL))        {            // (*env)->ReleaseCharArrayElements(env,channel,buf,0);            (*env)->ReleaseStringUTFChars(env,id,str_id);            (*env)->ReleaseStringUTFChars(env,ip,str_ip);            (*env)->ReleaseStringUTFChars(env,username,str_user);            (*env)->ReleaseStringUTFChars(env,password,str_pwd);            return (jint)-1;        }        nc_dev dev;        DeviceInit(&dev,(int)devicetype,str_id,str_ip,(int)port,(int)sport,str_user,str_pwd);        (*env)->ReleaseStringUTFChars(env,id,str_id);        (*env)->ReleaseStringUTFChars(env,ip,str_ip);        (*env)->ReleaseStringUTFChars(env,username,str_user);        (*env)->ReleaseStringUTFChars(env,password,str_pwd);        ptc_cfg_av_t av;        memset(&av,0,sizeof(ptc_cfg_av_t));        int ret=nc_getCfg_av(&dev, &av);        if(ret<0)            return (jint)ret;        jclass store_cls = (*env)->GetObjectClass(env,config);//FindClass无法找到，原因未知，直接传入类，暂时解决该问题        if(store_cls == NULL)        {            LOGI("GetObjectClasseee");            return -99;        }        //获得该类型的构造函数   返回类型必须为 void 即 V 如果有混淆代码需要保持该名称不改变        jmethodID store_set = (*env)->GetMethodID(env,store_cls,"setVideoInfo","(I)V");        (*env)->CallVoidMethod(env,config,store_set,(jint)av.mask);        return ret;    }/** * 设置视频参数 */    JNIEXPORT jint JNICALL Java_com_hdcctv_issmobile_NetApi_SetVideoCfg(JNIEnv *env, jobject obj,jint devicetype,                                                                        jstring id,jstring ip, jint port, jint sport,jstring username, jstring password,jobject config)    {        jboolean iscopy;        const char* str_id = (*env)->GetStringUTFChars(env,id,NULL);        const char* str_ip = (*env)->GetStringUTFChars(env,ip,NULL);        const char* str_user = (*env)->GetStringUTFChars(env,username,NULL);        const char* str_pwd = (*env)->GetStringUTFChars(env,password,NULL);        if((str_ip == NULL) || (str_user == NULL) || (str_pwd == NULL))        {            // (*env)->ReleaseCharArrayElements(env,channel,buf,0);            (*env)->ReleaseStringUTFChars(env,id,str_id);            (*env)->ReleaseStringUTFChars(env,ip,str_ip);            (*env)->ReleaseStringUTFChars(env,username,str_user);            (*env)->ReleaseStringUTFChars(env,password,str_pwd);            return (jint)-1;        }        nc_dev dev;        DeviceInit(&dev,(int)devicetype,str_id,str_ip,(int)port,(int)sport,str_user,str_pwd);        (*env)->ReleaseStringUTFChars(env,id,str_id);        (*env)->ReleaseStringUTFChars(env,ip,str_ip);        (*env)->ReleaseStringUTFChars(env,username,str_user);        (*env)->ReleaseStringUTFChars(env,password,str_pwd);        jclass info_cls = (*env)->GetObjectClass(env,config);//FindClass无法找到，原因未知，直接传入类，暂时解决该问题        if(info_cls == NULL)        {            LOGI("GetObjectClasseee");            return -99;        }        jfieldID mask_FiledId = (*env)->GetFieldID(env,info_cls,"mask","I");        jint mask = (jint)(*env)->GetIntField(env,config ,mask_FiledId);        ptc_cfg_av_t av;        memset(&av,0,sizeof(ptc_cfg_av_t));        av.mask = mask;        int ret=nc_setCfg_av(&dev, &av);        return (jint)ret;    }/** * 查询工作模式 */    JNIEXPORT jint JNICALL Java_com_hdcctv_issmobile_NetApi_GetWorkMode(JNIEnv *env, jobject obj,jint devicetype,                                                                        jstring id,jstring ip, jint port, jint sport,jstring username, jstring password)    {        jboolean iscopy;        const char* str_id = (*env)->GetStringUTFChars(env,id,NULL);        const char* str_ip = (*env)->GetStringUTFChars(env,ip,NULL);        const char* str_user = (*env)->GetStringUTFChars(env,username,NULL);        const char* str_pwd = (*env)->GetStringUTFChars(env,password,NULL);        if((str_ip == NULL) || (str_user == NULL) || (str_pwd == NULL))        {            // (*env)->ReleaseCharArrayElements(env,channel,buf,0);            (*env)->ReleaseStringUTFChars(env,id,str_id);            (*env)->ReleaseStringUTFChars(env,ip,str_ip);            (*env)->ReleaseStringUTFChars(env,username,str_user);            (*env)->ReleaseStringUTFChars(env,password,str_pwd);            return (jint)-1;        }        nc_dev dev;        DeviceInit(&dev,(int)devicetype,str_id,str_ip,(int)port,(int)sport,str_user,str_pwd);        (*env)->ReleaseStringUTFChars(env,id,str_id);        (*env)->ReleaseStringUTFChars(env,ip,str_ip);        (*env)->ReleaseStringUTFChars(env,username,str_user);        (*env)->ReleaseStringUTFChars(env,password,str_pwd);        ptc_cfg_workMode_t work_mode;        memset(&work_mode,0,sizeof(ptc_cfg_workMode_t));        int ret = nc_getCfg_workMode(&dev, &work_mode);        if(ret < 0)        {            return ret;        }        else            return work_mode.mode;    }/** * 设置工作模式 */    JNIEXPORT jint JNICALL Java_com_hdcctv_issmobile_NetApi_SetWorkMode(JNIEnv *env, jobject obj,jint devicetype,                                                                        jstring id,jstring ip, jint port, jint sport,jstring username, jstring password, jint mode)    {        jboolean iscopy;        const char* str_id = (*env)->GetStringUTFChars(env,id,NULL);        const char* str_ip = (*env)->GetStringUTFChars(env,ip,NULL);        const char* str_user = (*env)->GetStringUTFChars(env,username,NULL);        const char* str_pwd = (*env)->GetStringUTFChars(env,password,NULL);        if((str_ip == NULL) || (str_user == NULL) || (str_pwd == NULL))        {            // (*env)->ReleaseCharArrayElements(env,channel,buf,0);            (*env)->ReleaseStringUTFChars(env,id,str_id);            (*env)->ReleaseStringUTFChars(env,ip,str_ip);            (*env)->ReleaseStringUTFChars(env,username,str_user);            (*env)->ReleaseStringUTFChars(env,password,str_pwd);            return (jint)-1;        }        nc_dev dev;        DeviceInit(&dev,(int)devicetype,str_id,str_ip,(int)port,(int)sport,str_user,str_pwd);        (*env)->ReleaseStringUTFChars(env,id,str_id);        (*env)->ReleaseStringUTFChars(env,ip,str_ip);        (*env)->ReleaseStringUTFChars(env,username,str_user);        (*env)->ReleaseStringUTFChars(env,password,str_pwd);        ptc_cfg_workMode_t work_mode;        memset(&work_mode,0,sizeof(ptc_cfg_workMode_t));        work_mode.mode = (int)mode;        int ret = nc_setCfg_workMode(&dev, &work_mode);        return ret;    }