/*********************************************************** Copyright 1992 by Stichting Mathematisch Centrum, Amsterdam, The Netherlands.  All Rights Reserved  Permission to use, copy, modify, and distribute this software and its documentation for any purpose and without fee is hereby granted, provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in supporting documentation, and that the names of Stichting Mathematisch Centrum or CWI not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.  STICHTING MATHEMATISCH CENTRUM DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL STICHTING MATHEMATISCH CENTRUM BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  ******************************************************************//* *  Cleaned up by Phil Frisbie for use in HawkVoice *//* ** Intel/DVI ADPCM coder/decoder. ** ** The algorithm for this coder was taken from the IMA Compatability Project ** proceedings, Vol 2, Number 2; May 1992. ** ** Version 1.2, 18-Dec-92. ** ** Change log: ** - Fixed a stupid bug, where the delta was computed as **   stepsize*code/4 in stead of stepsize*(code+0.5)/4. ** - There was an off-by-one error causing it to pick **   an incorrect delta once in a blue moon. ** - The NODIVMUL define has been removed. Computations are now always done **   using shifts, adds and subtracts. It turned out that, because the standard **   is defined using shift/add/subtract, you needed bits of fixup code **   (because the div/mul simulation using shift/add/sub made some rounding **   errors that real div/mul don't make) and all together the resultant code **   ran slower than just using the shifts all the time. ** - Changed some of the variable names to be more meaningful. */#include "adpcm.h"adpcm_state* adpcm_begin(){    adpcm_state* state = (adpcm_state*)malloc(sizeof(adpcm_state));    if (state == 0)        return -1;    memset(state, 0, sizeof(adpcm_state));    state->index = 0;    state->valprev = 0;    return state;}void adpcm_end(adpcm_state* state){    if (state)        free(state);    //state->index = 0;    //state->valprev = 0;}/* Intel ADPCM step variation table */static int indexTable[16] = {        -1, -1, -1, -1, 2, 4, 6, 8,        -1, -1, -1, -1, 2, 4, 6, 8,};static unsigned int stepsizeTable[89] = {        7, 8, 9, 10, 11, 12, 13, 14, 16, 17,        19, 21, 23, 25, 28, 31, 34, 37, 41, 45,        50, 55, 60, 66, 73, 80, 88, 97, 107, 118,        130, 143, 157, 173, 190, 209, 230, 253, 279, 307,        337, 371, 408, 449, 494, 544, 598, 658, 724, 796,        876, 963, 1060, 1166, 1282, 1411, 1552, 1707, 1878, 2066,        2272, 2499, 2749, 3024, 3327, 3660, 4026, 4428, 4871, 5358,        5894, 6484, 7132, 7845, 8630, 9493, 10442, 11487, 12635, 13899,        15289, 16818, 18500, 20350, 22385, 24623, 27086, 29794, 32767};int adpcm_coder(short *indata, unsigned char *outdata, int len, adpcm_state *state){    short *inp;			/* Input buffer pointer */    unsigned char *outp;/* output buffer pointer */    int val;			/* Current input sample value */    int sign;			/* Current adpcm sign bit */    unsigned int delta;	/* Current adpcm output value */    int diff;			/* Difference between val and valprev */    unsigned int udiff; /* unsigned value of diff */    unsigned int step;	/* Stepsize */    int valpred;		/* Predicted output value */    unsigned int vpdiff;/* Current change to valpred */    int index;			/* Current step change index */    unsigned int outputbuffer = 0;/* place to keep previous 4-bit value */    int bufferstep;		/* toggle between outputbuffer/output */    int count = 0;      /* the number of bytes encoded */    outp = outdata;    inp = indata;    valpred = state->valprev;    index = (int)state->index;    step = stepsizeTable[index];    bufferstep = 1;    while (len-- > 0 ) {        val = *inp++;        /* Step 1 - compute difference with previous value */        diff = val - valpred;        if(diff < 0)        {            sign = 8;            diff = (-diff);        }        else        {            sign = 0;        }        /* diff will be positive at this point */        udiff = (unsigned int)diff;        /* Step 2 - Divide and clamp */        /* Note:         ** This code *approximately* computes:         **    delta = diff*4/step;         **    vpdiff = (delta+0.5)*step/4;         ** but in shift step bits are dropped. The net result of this is         ** that even if you have fast mul/div hardware you cannot put it to         ** good use since the fixup would be too expensive.         */        delta = 0;        vpdiff = (step >> 3);        if ( udiff >= step ) {            delta = 4;            udiff -= step;            vpdiff += step;        }        step >>= 1;        if ( udiff >= step  ) {            delta |= 2;            udiff -= step;            vpdiff += step;        }        step >>= 1;        if ( udiff >= step ) {            delta |= 1;            vpdiff += step;        }        /* Phil Frisbie combined steps 3 and 4 */        /* Step 3 - Update previous value */        /* Step 4 - Clamp previous value to 16 bits */        if ( sign != 0 )        {            valpred -= vpdiff;            if ( valpred < -32768 )                valpred = -32768;        }        else        {            valpred += vpdiff;            if ( valpred > 32767 )                valpred = 32767;        }        /* Step 5 - Assemble value, update index and step values */        delta |= sign;        index += indexTable[delta];        if ( index < 0 ) index = 0;        if ( index > 88 ) index = 88;        step = stepsizeTable[index];        /* Step 6 - Output value */        if ( bufferstep != 0 ) {            outputbuffer = (delta << 4);        } else {            *outp++ = (char)(delta | outputbuffer);            count++;        }        bufferstep = !bufferstep;    }    /* Output last step, if needed */    if ( bufferstep == 0 )    {        *outp++ = (char)outputbuffer;        count++;    }    state->valprev = (short)valpred;    state->index = (char)index;    return count;}/********************************************************************* Function閿涙矮濞囬悽鈺漝pcm鐟欙絿鐖滅亸鍡楁磽娴ｅ秶娈戦崢瀣級閺佺増宓佹潻妯哄斧閹达拷6娴ｅ潮cm Author閿涙ricjiang Input閿涙nbuff閿涙俺顩︾憴锝囩垳閻ㄥ嫭鏆熼幑顕嗙幢outbuff閿涙艾鍑＄憴锝囩垳閺佺増宓侀敍瀹璭n_of_in閿涙俺绶崗銉ф畱缂傛牜鐖滈弫鐗堝祦闂�鍨閿涙硞tate閿涙矮绗傛稉锟筋偧缂傛牜鐖滄担璺ㄦ暏閻ㄥ嫮绱惍浣革拷閸滃瞼鍌ㄥ鏇礄瀵拷顫愰柈鍊熺ゴ閸婇棿璐�0閿涳拷 Ouput閿涳拷 *********************************************************************/int adpcm_decoder(unsigned char *indata, short *outdata, int len, adpcm_state *state){    unsigned char *inp;	/* Input buffer pointer */    short *outp;		/* output buffer pointer */    unsigned int sign;	/* Current adpcm sign bit */    unsigned int delta;	/* Current adpcm output value */    unsigned int step;	/* Stepsize */    int valpred;		/* Predicted value */    unsigned int vpdiff;/* Current change to valpred */    int index;			/* Current step change index */    unsigned int inputbuffer = 0;/* place to keep next 4-bit value */    int bufferstep;		/* toggle between inputbuffer/input */    int count = 0;    outp = outdata;    inp = indata;    valpred = state->valprev;    index = (int)state->index;    step = stepsizeTable[index];    bufferstep = 0;    len *= 2;    while ( len-- > 0 ) {        /* Step 1 - get the delta value */        if ( bufferstep != 0 ) {            delta = inputbuffer & 0xf;        } else {            inputbuffer = (unsigned int)*inp++;            delta = (inputbuffer >> 4);        }        bufferstep = !bufferstep;        /* Step 2 - Find new index value (for later) */        index += indexTable[delta];        if ( index < 0 ) index = 0;        if ( index > 88 ) index = 88;        /* Step 3 - Separate sign and magnitude */        sign = delta & 8;        delta = delta & 7;        /* Phil Frisbie combined steps 4 and 5 */        /* Step 4 - Compute difference and new predicted value */        /* Step 5 - clamp output value */        /*         ** Computes 'vpdiff = (delta+0.5)*step/4', but see comment         ** in adpcm_coder.         */        vpdiff = step >> 3;        if ( (delta & 4) != 0 ) vpdiff += step;        if ( (delta & 2) != 0 ) vpdiff += step>>1;        if ( (delta & 1) != 0 ) vpdiff += step>>2;        if ( sign != 0 )        {            valpred -= vpdiff;            if ( valpred < -32768 )                valpred = -32768;        }        else        {            valpred += vpdiff;            if ( valpred > 32767 )                valpred = 32767;        }        /* Step 6 - Update step value */        step = stepsizeTable[index];        /* Step 7 - Output value */        *outp++ = (short)valpred;        count++;    }    state->valprev = (short)valpred;    state->index = (char)index;    return count;}